initSidebarItems({"constant":[["ADDRESS","Address of the PoS account implemented as a native VP"],["SLASH_POOL_ADDRESS","Address of the PoS slash pool account"]],"fn":[["bond_tokens","Self-bond tokens to a validator when `source` is `None` or equal to the `validator` address, or delegate tokens from the `source` to the `validator`."],["bonds_for_source_prefix","Storage key prefix for all bonds of the given source address."],["bonds_prefix","Storage key prefix for all bonds."],["get_validator_address_from_bond","Get validator address from bond key"],["init_genesis_storage","Initialize storage in the genesis block."],["init_validator","Attempt to initialize a validator account. On success, returns the initialized validator account’s address and its staking reward address."],["is_bond_key","Is storage key for a bond?"],["is_params_key","Is storage key for PoS parameters?"],["is_pos_key","Is the given key a PoS storage key?"],["is_total_voting_power_key","Is storage key for total voting power?"],["is_unbond_key","Is storage key for a unbond?"],["is_validator_address_raw_hash_key","Is storage key for validator’s address raw hash?"],["is_validator_consensus_key_key","Is storage key for validator’s consensus key?"],["is_validator_set_key","Is storage key for a validator set?"],["is_validator_slashes_key","Is storage key for validator’s slashes?"],["is_validator_staking_reward_address_key","Is storage key for validator’s staking reward address?"],["is_validator_state_key","Is storage key for validator’s state?"],["is_validator_total_deltas_key","Is storage key for validator’s total deltas?"],["is_validator_voting_power_key","Is storage key for validator’s voting power?"],["slashes_prefix","Storage prefix for slashes."],["staking_token_address","Address of the staking token (XAN)"],["unbond_tokens","Unbond self-bonded tokens from a validator when `source` is `None` or equal to the `validator` address, or unbond delegated tokens from the `source` to the `validator`."],["unbonds_for_source_prefix","Storage key prefix for all unbonds of the given source address."],["unbonds_prefix","Storage key prefix for all unbonds."],["withdraw_tokens","Withdraw unbonded tokens from a self-bond to a validator when `source` is `None` or equal to the `validator` address, or withdraw unbonded tokens delegated to the `validator` to the `source`."]],"mod":[["epoched","[`Epoched`] and [`EpochedDelta`] are structures for data that is set for future epochs at a given [`EpochOffset`]."],["parameters","Proof-of-Stake system parameters"],["types","Proof of Stake data types"],["vp","Proof-of-Stake native validity predicate."]],"struct":[["PoS","Proof of Stake system. This struct integrates and gives access to lower-level PoS functions."],["PosParams","Proof-of-Stake system parameters"],["PosVP","Proof-of-Stake validity predicate"]],"trait":[["PosRead","Read-only part of the PoS system"],["PosWrite","PoS system trait to be implemented in integration that can read and write PoS data."]],"type":[["BondId","Alias for a PoS type with the same name with concrete type parameters"],["Bonds","Alias for a PoS type with the same name with concrete type parameters"],["GenesisValidator","Alias for a PoS type with the same name with concrete type parameters"],["Slashes","Slashes applied to validator, to punish byzantine behavior by removing their staked tokens at and before the epoch of the slash."],["TotalVotingPowers","Epoched total voting power."],["Unbonds","Alias for a PoS type with the same name with concrete type parameters"],["ValidatorConsensusKeys","Alias for a PoS type with the same name with concrete type parameters"],["ValidatorSets","Alias for a PoS type with the same name with concrete type parameters"],["ValidatorStates","Epoched validator’s state."],["ValidatorTotalDeltas","Alias for a PoS type with the same name with concrete type parameters"],["ValidatorVotingPowers","Epoched validator’s voting power."]]});