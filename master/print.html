<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Anoma - DOCS</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="assets/custom.css">
        <link rel="stylesheet" href="mdbook-admonish.css">

        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="explore/index.html"><strong aria-hidden="true">2.</strong> Exploration</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="explore/design/index.html"><strong aria-hidden="true">2.1.</strong> Design</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="explore/design/overview.html"><strong aria-hidden="true">2.1.1.</strong> Overview</a></li><li class="chapter-item expanded "><a href="explore/design/gossip.html"><strong aria-hidden="true">2.1.2.</strong> Gossip network</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="explore/design/intent_gossip/intent_gossip.html"><strong aria-hidden="true">2.1.2.1.</strong> Intent gossip</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="explore/design/intent_gossip/intent.html"><strong aria-hidden="true">2.1.2.1.1.</strong> Intent</a></li><li class="chapter-item expanded "><a href="explore/design/intent_gossip/topic.html"><strong aria-hidden="true">2.1.2.1.2.</strong> Topic</a></li><li class="chapter-item expanded "><a href="explore/design/intent_gossip/incentive.html"><strong aria-hidden="true">2.1.2.1.3.</strong> Incentive</a></li><li class="chapter-item expanded "><a href="explore/design/intent_gossip/matchmaker.html"><strong aria-hidden="true">2.1.2.1.4.</strong> Matchmaker</a></li><li class="chapter-item expanded "><a href="explore/design/intent_gossip/fungible_token.html"><strong aria-hidden="true">2.1.2.1.5.</strong> Fungible token</a></li></ol></li><li class="chapter-item expanded "><a href="explore/design/dkg.html"><strong aria-hidden="true">2.1.2.2.</strong> Distributed key generation gossip</a></li></ol></li><li class="chapter-item expanded "><a href="explore/design/ledger.html"><strong aria-hidden="true">2.1.3.</strong> The ledger</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="explore/design/ledger/parameters.html"><strong aria-hidden="true">2.1.3.1.</strong> Parameters</a></li><li class="chapter-item expanded "><a href="explore/design/ledger/epochs.html"><strong aria-hidden="true">2.1.3.2.</strong> Epochs</a></li><li class="chapter-item expanded "><a href="explore/design/ledger/accounts.html"><strong aria-hidden="true">2.1.3.3.</strong> Accounts</a></li><li class="chapter-item expanded "><a href="explore/design/ledger/vp.html"><strong aria-hidden="true">2.1.3.4.</strong> Validity predicates</a></li><li class="chapter-item expanded "><a href="explore/design/ledger/tx.html"><strong aria-hidden="true">2.1.3.5.</strong> Transactions</a></li><li class="chapter-item expanded "><a href="explore/design/ledger/wasm-vm.html"><strong aria-hidden="true">2.1.3.6.</strong> WASM VM</a></li><li class="chapter-item expanded "><a href="explore/design/ledger/front-running.html"><strong aria-hidden="true">2.1.3.7.</strong> Front-running prevention</a></li><li class="chapter-item expanded "><a href="explore/design/ledger/fractal-scaling.html"><strong aria-hidden="true">2.1.3.8.</strong> Fractal scaling</a></li><li class="chapter-item expanded "><a href="explore/design/upgrade-system.html"><strong aria-hidden="true">2.1.3.9.</strong> Upgrade system</a></li><li class="chapter-item expanded "><a href="explore/design/ledger/storage.html"><strong aria-hidden="true">2.1.3.10.</strong> Storage</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="explore/design/ledger/storage/data-schema.html"><strong aria-hidden="true">2.1.3.10.1.</strong> Data schema</a></li></ol></li><li class="chapter-item expanded "><a href="explore/design/ledger/pos-integration.html"><strong aria-hidden="true">2.1.3.11.</strong> PoS integration</a></li></ol></li><li class="chapter-item expanded "><a href="explore/design/crypto-primitives.html"><strong aria-hidden="true">2.1.4.</strong> Crypto primitives</a></li><li class="chapter-item expanded "><a href="explore/design/actors.html"><strong aria-hidden="true">2.1.5.</strong> Actors</a></li><li class="chapter-item expanded "><a href="explore/design/pos.html"><strong aria-hidden="true">2.1.6.</strong> Proof of Stake system</a></li><li class="chapter-item expanded "><a href="explore/design/testnet-setup.html"><strong aria-hidden="true">2.1.7.</strong> Testnet setup</a></li><li class="chapter-item expanded "><a href="explore/design/testnet-launch-procedure/index.html"><strong aria-hidden="true">2.1.8.</strong> Testnet launch procedure</a></li></ol></li><li class="chapter-item expanded "><a href="explore/prototypes/index.html"><strong aria-hidden="true">2.2.</strong> Prototypes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="explore/prototypes/base-ledger.html"><strong aria-hidden="true">2.2.1.</strong> Base ledger</a></li><li class="chapter-item expanded "><a href="explore/prototypes/gossip-layer.html"><strong aria-hidden="true">2.2.2.</strong> Gossip layer</a></li></ol></li><li class="chapter-item expanded "><a href="explore/libraries/index.html"><strong aria-hidden="true">2.3.</strong> Libraries &amp; Tools</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">2.3.1.</strong> Cryptography</div></li><li class="chapter-item expanded "><a href="explore/libraries/network.html"><strong aria-hidden="true">2.3.2.</strong> network</a></li><li class="chapter-item expanded "><a href="explore/libraries/cli.html"><strong aria-hidden="true">2.3.3.</strong> Command-line interface</a></li><li class="chapter-item expanded "><a href="explore/libraries/db.html"><strong aria-hidden="true">2.3.4.</strong> Database</a></li><li class="chapter-item expanded "><a href="explore/libraries/logging.html"><strong aria-hidden="true">2.3.5.</strong> Logging</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.3.6.</strong> Networking</div></li><li class="chapter-item expanded "><a href="explore/libraries/packaging.html"><strong aria-hidden="true">2.3.7.</strong> Packaging</a></li><li class="chapter-item expanded "><a href="explore/libraries/serialization.html"><strong aria-hidden="true">2.3.8.</strong> Serialization</a></li><li class="chapter-item expanded "><a href="explore/libraries/wasm.html"><strong aria-hidden="true">2.3.9.</strong> WASM runtime</a></li><li class="chapter-item expanded "><a href="explore/libraries/errors.html"><strong aria-hidden="true">2.3.10.</strong> Error handling</a></li></ol></li><li class="chapter-item expanded "><a href="explore/design/glossary.html"><strong aria-hidden="true">2.4.</strong> Glossary</a></li><li class="chapter-item expanded "><a href="explore/resources/index.html"><strong aria-hidden="true">2.5.</strong> Resources</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="explore/resources/ide.html"><strong aria-hidden="true">2.5.1.</strong> IDE</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="specs/index.html"><strong aria-hidden="true">3.</strong> Specifications</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="specs/overview.html"><strong aria-hidden="true">3.1.</strong> Overview</a></li><li class="chapter-item expanded "><a href="specs/ledger.html"><strong aria-hidden="true">3.2.</strong> The ledger</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="specs/ledger/rpc.html"><strong aria-hidden="true">3.2.1.</strong> RPC</a></li><li class="chapter-item expanded "><a href="specs/ledger/default-transactions.html"><strong aria-hidden="true">3.2.2.</strong> Default transactions</a></li><li class="chapter-item expanded "><a href="specs/ledger/default-validity-predicates.html"><strong aria-hidden="true">3.2.3.</strong> Default validity predicates</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.3.</strong> Trade system</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.4.</strong> Intent gossip system</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.5.</strong> Fractal scaling</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.6.</strong> Upgrade system</div></li><li class="chapter-item expanded "><a href="specs/crypto.html"><strong aria-hidden="true">3.7.</strong> Crypto</a></li><li class="chapter-item expanded "><a href="specs/encoding.html"><strong aria-hidden="true">3.8.</strong> Encoding</a></li></ol></li><li class="chapter-item expanded "><a href="archive/index.html"><strong aria-hidden="true">4.</strong> Archive</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="archive/domain-name-addresses.html"><strong aria-hidden="true">4.1.</strong> Domain name addresses</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Anoma - DOCS</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/anoma/anoma" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Welcome to Anoma's docs!</p>
<h2 id="about-anoma"><a class="header" href="#about-anoma">About Anoma</a></h2>
<p><a href="https://anoma.network/">Anoma</a> is a sovereign, proof-of-stake blockchain protocol that enables private, asset-agnostic cash and private bartering among any number of parties. To learn more about the protocol, we recommend the following resources:</p>
<ul>
<li><a href="https://medium.com/anomanetwork/introducing-anoma-a-blockchain-for-private-asset-agnostic-bartering-dcc47ac42d9f">Introduction to Anoma Medium article</a></li>
<li><a href="https://anoma.network/papers/whitepaper.pdf">Anoma's Whitepaper</a></li>
<li><a href="https://anoma.network/papers/vision-paper.pdf">Anoma's Vision paper</a></li>
</ul>
<blockquote>
<p>⚠️ Here lay dragons: this codebase is still experimental, try at your own risk!</p>
</blockquote>
<h2 id="about-the-documentation"><a class="header" href="#about-the-documentation">About the documentation</a></h2>
<p>The two main sections of this book are:</p>
<ul>
<li><a href="./explore">Exploration</a>: documents the process of exploring the design and implementation space for Anoma</li>
<li><a href="./specs">Specifications</a>: implementation independent technical specifications</li>
</ul>
<p>The Anoma user guide and networks documentation can be found at <a href="https://docs.anoma.net">https://docs.anoma.net</a>.</p>
<h3 id="the-source"><a class="header" href="#the-source">The source</a></h3>
<p>This book is written using <a href="https://rust-lang.github.io/mdBook/">mdBook</a> with <a href="https://github.com/badboy/mdbook-mermaid">mdbook-mermaid</a> for diagrams, it currently lives in the <a href="https://github.com/anoma/anoma">Anoma repo</a>.</p>
<p>To get started quickly, in the <code>docs</code> directory one can:</p>
<pre><code class="language-shell"># Install dependencies
make dev-deps

# This will open the book in your default browser and rebuild on changes
make serve
</code></pre>
<p>The mermaid diagrams docs can be found at <a href="https://mermaid-js.github.io/mermaid">https://mermaid-js.github.io/mermaid</a>.</p>
<p><a href="https://github.com/anoma/anoma/issues">Contributions</a> to the contents and the structure of this book (nothing is set in stone) should be made via pull requests. Code changes that diverge from the spec should also update this book.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exploration"><a class="header" href="#exploration">Exploration</a></h1>
<p>This section documents the process of exploring the design and implementation space for Anoma. Ideally, the captured information should provide an overview of the explored space and help to guide further decisions.</p>
<p>The content of this section is more free-form. This is largely a cross-over of both the implementation details and the design of implementation-independent specifications.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="design"><a class="header" href="#design">Design</a></h1>
<p>This section covers the exploration of the possible design directions of the involved components.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overview"><a class="header" href="#overview">Overview</a></h1>
<blockquote>
<p>⚠️ This section is WIP.</p>
</blockquote>
<ul>
<li>TODO: add high-level interaction diagram(s)</li>
</ul>
<p>The Rust crates internal dependency graph:</p>
<p><img src="explore/design/./overview/crates.svg" alt="crates" title="crates" />
<a href="https://excalidraw.com/#room=e32fc914de750ed4f5e4,6CWRFjnmCoiFR4BQ6i9K4g">Diagram on Excalidraw</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-gossip-network"><a class="header" href="#the-gossip-network">The gossip network</a></h1>
<p>The gossip network runs in parallel to the ledger network and is used to
propagate off-chain information. The network is based on
<a href="https://libp2p.io/">libp2p</a> , a peer to peer network system that is implemented
in different languages, has a large user base and an active development.  It
allows us to readily implement a network to run our application.</p>
<p>The gossip network is used to propagate messages of two different applications,
intents for the <a href="explore/design/intent_gossip/intent_gossip.html">intent gossip system</a>, and message for distributed keys
generation application.</p>
<h2 id="flow-diagram-high-level-overview"><a class="header" href="#flow-diagram-high-level-overview">Flow diagram: High level overview</a></h2>
<p><img src="explore/design/./gossip_process.svg" alt="gossip process" title="gossip process" /></p>
<p><a href="https://excalidraw.com/#room=5d4a2a84ef52cf5f5f96,r4ghl40frJ9putMy-0vyOQ">Diagram on Excalidraw</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="intent-gossip-network"><a class="header" href="#intent-gossip-network">Intent gossip network</a></h1>
<p>The intent gossip network enables counterparty discovery for bartering. The
users can express any sort of intents that might be matched and transformed into
a transaction that fulfills the intents on the Anoma ledger.</p>
<p>An <a href="explore/design/intent_gossip/./intent.html">intent</a> describes the desire of a user, from asset exchange to a
green tax percent for selling shoes. These intents are picked up by a matchmaker
that composes them into transactions to send to the ledger network. A matchmaker
is optionally included in the intent gossip node.</p>
<p>Each node connects to a specified intent gossip network, either a public or a
private one. Anyone can create their own network where they decide all aspects
of it: which type of intents is propagated, which nodes can participate, the
matchmaker logic, etc. It is possible, for example, to run the intent gossip system
over bluetooth to have it off-line.</p>
<p>An intent gossip node is a peer in the intent gossip network that has the role
of propagating intents to all other connected nodes.</p>
<p>The network uses the
<a href="https://github.com/libp2p/specs/tree/512accdd81e35480911499cea14e7d7ea019f71b/pubsub/gossipsub">gossipsub</a>
network behaviour. This system aggregates nodes around topics of interest. Each
node subscribes to a set of topics and connects to other nodes that are also
subscribed to the same topics. A topic defines a sub-network for a defined
interest, e.g. “asset_exchange”. see
<a href="https://github.com/libp2p/specs/tree/512accdd81e35480911499cea14e7d7ea019f71b/pubsub/gossipsub">gossipsub</a>
for more information on the network topology.</p>
<p>Each node has an incentive to propagate intents and will obtain a small portion
of the fees if the intent is settled. (TODO: update when logic is found) See
<a href="explore/design/intent_gossip/./incentive.html">incentive</a> for more information.</p>
<h3 id="flow-diagram-asset-exchange"><a class="header" href="#flow-diagram-asset-exchange">Flow diagram: asset exchange</a></h3>
<p>This example shows three intents matched together by the intent gossip network.
These three intents express user desires to exchange assets.</p>
<p><img src="explore/design/intent_gossip/./example.svg" alt="intent gossip and ledger network interaction" title="intent gossip network" />
<a href="https://excalidraw.com/#room=257e44f4b4b5867bf541,XDEKyGVIpqCrfq55bRqKug">Diagram on Excalidraw</a></p>
<h1 id="flow-diagram-life-cycle-of-intent-and-global-process"><a class="header" href="#flow-diagram-life-cycle-of-intent-and-global-process">Flow diagram: life cycle of intent and global process</a></h1>
<p>This diagram shows the process flow for intents, from users expressing their
desire to the ledger executing the validity predicate to check the crafted
transaction.</p>
<p><img src="explore/design/intent_gossip/./intent_life_cycle.svg" alt="intent life cycle" title="intent life
cycle" /> 
<a href="https://excalidraw.com/#room=7ac107b3757c64049003,cdMInfvdLtjaGWSZWEKrhw">Diagram on Excalidraw</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="intents"><a class="header" href="#intents">Intents</a></h1>
<p>An intent is a way of expressing a user's desire. It is defined as arbitrary
data and an optional address for a schema. The data is as arbitrary as possible
to allow the users to express any sort of intent. It could range from defining a
selling order for a specific token to offering piano lessons or even proposing a
green tax for shoes’ manufacturers.</p>
<p>An intent is written using an encoding, or data schema. The encoding exists
either on-chain or off-chain. It must be known by users that want to express
similar intents. It also must be understood by some matchmaker. Otherwise, it 
possibly won’t be  matched. The user can define its own schema and inform either 
off-chain or on-chain. Having it on-chain allows it to easily share it with other
participants. Please refer to <a href="explore/design/intent_gossip/./../ledger/storage/data-schema.html">data schema</a> for more
information about the usage of on-chain schema.</p>
<hr />
<p>There is only a single intent type that is composed of arbitrary data and a
possible schema definition.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Intent {
    schema: Option&lt;Key&gt;,
    data: Vec&lt;u8&gt;,
    timestamp: Timestamp
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="topic"><a class="header" href="#topic">Topic</a></h1>
<p>A topic is string and an encoding that describes this sub-network. In a topic
all intents use the exact same encoding. That encoding is known by matchmakers
so it can decode them to find matches. Whenever a node subscribes to a new topic
it informs all connected nodes and each of them propagate it. With this it’s
easy to create new topics in the intent gossip network and inform others.</p>
<p>Other nodes can choose to subscribe to a new topic with the help of a
filter. This filter is defined as a combination of a whitelist, a regex
expression, and a maximum limit.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="incentive"><a class="header" href="#incentive">Incentive</a></h1>
<p><a href="https://github.com/anoma/anoma/issues/37">Tracking Issue</a></p>
<hr />
<p>TODO</p>
<ul>
<li>describe incentive function</li>
<li>describe logic to ensure matchmaker can't cheat intent gossip service</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="matchmaker"><a class="header" href="#matchmaker">Matchmaker</a></h1>
<p>The matchmaker is a specific actor in the intent gossip network that tries to
match intents together. When intents are matched together, the matchmaker crafts
a transaction from them and sends it to the ledger network.</p>
<p>A matchmaker is an intent gossip node started with additional parameters: a
ledger address and a list of sub-matchmakers. A sub-matchmaker is defined with a
topics list, a main program path, a filter program path, and a transaction code.</p>
<p>The main and filter programs are wasm compiled code. Each has a defined
entrypoint and their own set of environment functions that they can call.</p>
<p>When the matchmaker receives a new intent from the network it calls the
corresponding sub-matchmaker, the one that has the intent’s topic in their
topics list. A sub-matchmaker first checks if the intent is accepted by the
filter, before adding it to that sub-matchmaker database. Then the main program
is called with the intent and current state.</p>
<h2 id="sub-matchmaker-topics-list"><a class="header" href="#sub-matchmaker-topics-list">Sub-matchmaker topics' list</a></h2>
<p>A sub-matchmaker is defined to work with only a subset of encoding. Each intent
propagated to the corresponding topic will be process by this sub-matchmaker.</p>
<p>Having a topics list instead of a unique topic allows a matchmaker to match
intents from different encodings. For example, when an updated version of an
encoding is out, the matchmaker could match intents from both versions if they
don’t diverge too much.</p>
<h2 id="sub-matchmaker-database-and-state-name-tbd"><a class="header" href="#sub-matchmaker-database-and-state-name-tbd">Sub-matchmaker database and state (name TBD)</a></h2>
<p>Each sub-matchmaker has a database and an arbitrary state.</p>
<p>The database contains intents received by the node from the topics list that
passed the filter.</p>
<p>The state is arbitrary data that is managed by the main program. That state is
given to all calls in the main program.</p>
<p>The database is persistent but the state is not. When a node is started the
state is recovered by giving all intents from the database to the main program.
The invariant that the current state is equal to the state if the node is
restarted is not enforced and is the responsibility of the main program.</p>
<h2 id="filter-program"><a class="header" href="#filter-program">Filter program</a></h2>
<p>The filter is an optional wasm program given in parameters. This filter is used
to check each intent received by that sub-matchmaker. If it's not defined,
intents are directly passed to the main program.</p>
<p>The entrypoint <code>filter_intent</code> takes an intent and returns a boolean. The
filter has the ability to query the state of the ledger for any given key.</p>
<h2 id="main-program"><a class="header" href="#main-program">Main program</a></h2>
<p>The main program is a mandatory wasm program given in parameters. The main
program must match together intents.</p>
<p>The main program entrypoint <code>match_intent</code> takes the current state, a new intent
data and its id. The main program also has the ability to query the state of the
ledger. It also has functions <code>remove</code> and <code>get</code> to interact with the matchmaker
mempool. When a main matchmaker program finds a match it sends a transaction to
the ledger composed of the code template given in the matchmaker parameter and
the data given to this function. Finally the matchmaker must update its state so
the next run will have up to date values.</p>
<p>The main program is called on two specific occasion; when intent gossip node is
started, on all intent from database and whenever a new intent is received from
the p2p network and the RPC endpoint, if enabled.</p>
<h2 id="transaction"><a class="header" href="#transaction">Transaction</a></h2>
<p>The transaction code given in parameters is used when the main program matches a
group of intents. The main program returns arbitrary data that is attached to
the transaction which is then injected into a ledger node.</p>
<h2 id="flow-diagram-matchmaker-process"><a class="header" href="#flow-diagram-matchmaker-process">Flow diagram: Matchmaker process</a></h2>
<p><img src="explore/design/intent_gossip/./matchmaker_process.svg" alt="matchmaker process" title="matchmaker process" /></p>
<p><a href="https://excalidraw.com/#room=92b291c13cfab8fb22a4,OvHfWIrL0jeDzPI-EFZMaw">excalidraw link</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fungible-token-encoding-and-template"><a class="header" href="#fungible-token-encoding-and-template">Fungible token encoding and template</a></h1>
<p>The Heliax team implemented an intent encoding, a filter program template, and a
matchmaker program template that can be used to exchange fungible tokens between
any number of participants.</p>
<h2 id="intent-encoding"><a class="header" href="#intent-encoding">Intent encoding</a></h2>
<p>The intent encoding allows the expression of a desire to participate in an asset
exchange. The encoding is defined as follows :</p>
<pre><code class="language-protobuf">message FungibleToken {
  string address = 1;
  string token_sell = 2;
  int64 max_sell = 3;
  int64 rate_min = 4;
  string token_buy = 5;
  int64 min_buy = 6;
  google.protobuf.Timestamp expire = 7;
}
</code></pre>
<h2 id="matchmaker-program"><a class="header" href="#matchmaker-program">Matchmaker program</a></h2>
<p>The filter program attempts to decode the intent and if successful, checks
that it's not yet expired and that the account address has enough funds for the
intended token to be sold.</p>
<p>The main program can match intents for exchanging assets. It does that by
creating a graph from all intents. When a cycle is found then it removes all
intents from that cycle of the mempool and crafts a transaction based on all the
removed intents.</p>
<p><img src="explore/design/intent_gossip/matchmaker_graph.svg" alt="matchmaker" />
<a href="https://excalidraw.com/#room=1db86ba6d5f0ccb7447c,2vvRd4X2Y3HDWHihJmy9zw">excalidraw link</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="distributed-key-generation-gossip"><a class="header" href="#distributed-key-generation-gossip">Distributed key generation gossip</a></h1>
<blockquote>
<p>⚠️ This section is WIP.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-ledger"><a class="header" href="#the-ledger">The ledger</a></h1>
<p>The ledger depends on <a href="https://github.com/tendermint/tendermint">Tendermint node</a>. Running the Anoma node will also initialize and run Tendermint node. Anoma communicates with Tendermint via the ABCI.</p>
<h2 id="overview-1"><a class="header" href="#overview-1">Overview</a></h2>
<p>The following diagram illustrates the current boundaries between the async and blocking code.</p>
<p><img src="explore/design/ledger/ledger_threads.svg" alt="ledger threads" title="ledger threads" />
<a href="https://excalidraw.com/#room=952eca1f17ac3c7b5cee,ReXYfqLLleTjVnSQM9zrjw">Diagram on Excalidraw</a></p>
<h2 id="threads-config"><a class="header" href="#threads-config">Threads config</a></h2>
<p>Configuration for threads usage can be changed via environment variables:</p>
<ul>
<li><code>ANOMA_TOKIO_THREADS</code>: Defaults to 1/2 logical cores</li>
<li><code>ANOMA_RAYON_THREADS</code>: Defaults to 1/2 logical cores.</li>
<li><code>ANOMA_ROCKSDB_COMPACTION_THREADS</code>: Defauls to 1/4 logical core. RocksDB also uses 1 more background thread for flushing.</li>
</ul>
<h2 id="tendermint-abci"><a class="header" href="#tendermint-abci">Tendermint ABCI</a></h2>
<p>We are using the Tendermint state-machine replication engine via ABCI. It provides many useful things, such as a BFT consensus protocol, P2P layer with peer exchange, block sync and mempool layer.</p>
<p>Useful resources:</p>
<ul>
<li>Tendermint ABCI <a href="https://docs.tendermint.com/master/spec/abci/">https://docs.tendermint.com/master/spec/abci/</a></li>
<li>Tendermint RPC reference <a href="https://docs.tendermint.com/master/rpc/">https://docs.tendermint.com/master/rpc/</a></li>
<li>Awesome collection <a href="https://github.com/tendermint/awesome">https://github.com/tendermint/awesome</a></li>
</ul>
<p>Rust ABCI implementations:</p>
<ul>
<li><a href="https://github.com/informalsystems/tendermint-rs">https://github.com/informalsystems/tendermint-rs</a>
<ul>
<li>the future update planned for this crate is to add async support</li>
<li>longer term the goal is to be able to <a href="https://github.com/informalsystems/tendermint-rs/issues/29#issuecomment-672444401">seamlessly switch from Go Tendermint
to Rust Tendermint</a></li>
<li>includes RPC and light-client libraries</li>
</ul>
</li>
<li><a href="https://github.com/devashishdxt/abci-rs">https://github.com/devashishdxt/abci-rs</a>
<ul>
<li>async support</li>
</ul>
</li>
<li><a href="https://github.com/tendermint/rust-abci">https://github.com/tendermint/rust-abci</a>
<ul>
<li>deprecated in favor of informalsystems/tendermint-rs</li>
</ul>
</li>
</ul>
<h3 id="abci-integration"><a class="header" href="#abci-integration">ABCI Integration</a></h3>
<p>The ledger wraps the Tendermint node inside the Anoma node. The Tendermint node
communicates with the Anoma shell via four layers as illustrated below.</p>
<pre class="mermaid">flowchart LR
    C[Client] --- R
    subgraph Anoma Node
    S((Anoma Shell))
    subgraph Tendermint ABCI
    R[RPC] === T{Tendermint}
    T --- TC[Consensus]
    T --- TM[Mempool]
    T --- TQ[Query]
    T --- TS[Snapshot]
    end
    TC --- S
    TM --- S
    TQ --- S
    TS --- S
    end
</pre>
<p>The <em>consensus</em> connection allows the shell to:</p>
<ul>
<li>initialize genesis on start-up</li>
<li>begin a block</li>
<li>apply a transaction(s) in a block</li>
<li>end a block</li>
<li>commit a block</li>
</ul>
<p>The <em>mempool</em> connection asks the shell to validate transactions before they get
stored in the mempool and broadcasted to peers. The mempool will signify that
the transaction is either new, when it has not been validated before, or to be
re-checked when it has been validated at some previous level.</p>
<p>The <em>query</em> connection is used for:</p>
<ul>
<li>the Tendermint node asks the last known state from the shell to determine if it needs to replay any blocks</li>
<li>relay client queries for some state at a given path to the shell</li>
</ul>
<p>The <em>snapshot</em> connection is used to serve state sync snapshots for other nodes and/or restore state sync snapshots to a local node being bootstrapped.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="parameters"><a class="header" href="#parameters">Parameters</a></h1>
<p>The parameters are used to dynamically control certain variables in the protocol. They are implemented as an internal address with a native VP. The current values are written into and read from the block storage in the parameters account's sub-space.</p>
<p>Initial parameters for a chain are set in the genesis configuration. On chain, these can be changed by 2/3 of voting power (specifics are TBA).</p>
<h2 id="epoch-duration"><a class="header" href="#epoch-duration">Epoch duration</a></h2>
<p>The parameters for <a href="explore/design/ledger/./epochs.html">epoch</a> duration are:</p>
<ul>
<li>Minimum number of blocks in an epoch</li>
<li>Minimum duration of an epoch</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="epochs"><a class="header" href="#epochs">Epochs</a></h1>
<p>An epoch is a range of blocks whose length is determined by the <a href="explore/design/ledger/./parameters.html#epoch-duration">epoch duration protocol parameter</a>: minimum epoch duration and minimum number of blocks in an epoch. They are identified by consecutive natural numbers starting at 0.</p>
<p>We store the current epoch in global storage and the epoch of each block in the block storage. We also store the minimum height and minimum time of a first block in the next epoch in global storage, so that changes to the epoch duration protocol parameter don't affect the current epoch, but rather apply from the following epoch. Note that protocol parameters changes may themselves be delayed.</p>
<p>The first epoch (ID 0) starts on the genesis block. The next epoch minimum start time is set to the genesis time configured for the chain + minimum duration and the next epoch minimum height is set to the height of the genesis block (typically 1) + minimum number of blocks.</p>
<p>On each block <code>BeginBlock</code> Tendermint call, we check if the current epoch is finished, in which case we move on to the next epoch. An epoch is finished when both the minimum number of blocks and minimum duration of an epoch have been created from the first block of a current epoch. When a new epoch starts, the next epoch minimum height is set to the block's height + minimum number of blocks and minimum start time time is set to block's time from the block header + minimum duration.</p>
<h2 id="predecessor-blocks-epochs"><a class="header" href="#predecessor-blocks-epochs">Predecessor blocks epochs</a></h2>
<p>We store the epoch ranges of predecessor blocks. This is used for example for to look-up the epoch from an evidence of validators that acted maliciously (which includes block height and block time) for PoS system. For the PoS system, in block at height <code>h</code>, we only need to know values from Tendermint <code>max(h - consensus_params.evidence.max_age_num_blocks, 0)</code>, which is set to <code>100000</code> by default.</p>
<p>The predecessor epochs are stored in the block storage.  We update this structure on every new epoch and trim any epochs that ended more than <code>max_age_num_blocks</code> ago.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="accounts"><a class="header" href="#accounts">Accounts</a></h1>
<p><a href="https://github.com/anoma/anoma/issues/45">Tracking Issue</a></p>
<hr />
<p>There's only a single account type. Each account is associated with:</p>
<ul>
<li>a unique <a href="explore/design/ledger/../../../specs/ledger.html#transparent-addresses">transparent address</a></li>
<li>a <a href="explore/design/ledger/./vp.html">validity predicate</a></li>
<li><a href="explore/design/ledger/accounts.html#dynamic-storage-sub-space">dynamic storage sub-space</a></li>
</ul>
<h2 id="shielded-addresses"><a class="header" href="#shielded-addresses">Shielded addresses</a></h2>
<p>Similar to <a href="https://raw.githubusercontent.com/zcash/zips/master/protocol/protocol.pdf">Zcash Sapling protocol payment addresses and keys (section 3.1)</a>, users can generate spending keys for private payments. A shielded payment address, incoming viewing key and full viewing key are derived from a spending key. In a private payment, a shielded payment address is hashed with a diversifier into a diversified transmission key. When a different diversifier function is chosen for different transactions, it prevents the transmission key from being matched across the transactions.</p>
<p>The encoding of the shielded addresses, spending and viewing keys is not yet decided, but for consistency we'll probably use a the same schema with different prefixes for anything that can use an identifier.</p>
<ul>
<li>TODO consider using a schema similar to the <a href="https://github.com/zcash/zips/issues/482">unified addresses proposed in Zcash</a>, that are designed to unify the payment addresses across different versions by encoding a typecode and the length of the payment address together with it. This may be especially useful for the protocol upgrade system and fractal scaling system.</li>
</ul>
<h2 id="dynamic-storage-sub-space"><a class="header" href="#dynamic-storage-sub-space">Dynamic storage sub-space</a></h2>
<p>Each account can have an associated dynamic account state in the storage. This
state may be comprised of keys of the built-in supported types and values of arbitrary user bytes.</p>
<p>The dynamic storage sub-space could be a unix filesystem-like tree under the
account's address key-space with <code>read, write, delete, has_key, iter_prefix</code>
(and maybe a few other convenience functions for hash-maps, hash-sets, optional values, etc.) functions parameterized with the the account's address.</p>
<p>In addition, the storage sub-space would provide:</p>
<ul>
<li>a public type/trait for storage keys and key segments:
<ul>
<li>this should allow to turn types to storage key segments, key segments back to types</li>
<li>combine key segments into keys</li>
<li>can be extended with custom types in the code in a transaction</li>
</ul>
</li>
<li>a public type/trait for storage values:
<ul>
<li>values need to implement encoding traits, e.g. <code>BorshSerialize, BorshDeserialize</code>
<ul>
<li>this allows composition of types as specified for <a href="https://borsh.io">Borsh</a></li>
<li>the Merkle tree hashing function should hash values from the encoded bytes of this trait (the encoded value may be cached, because we update the Merkle tree in-memory before we commit the finalized block to the DB)</li>
</ul>
</li>
</ul>
</li>
<li>functions to get the size of a key and an encoded value (for storage fees)</li>
<li>the updates to account storage should be immediately visible to the transaction that performed the updates
<ul>
<li>validity predicate modifications have to be handled a little differently -
the old validity predicate should be run to check that the new validity
predicate (and other state changes included in the transaction) is valid</li>
</ul>
</li>
</ul>
<h2 id="initializing-a-new-account"><a class="header" href="#initializing-a-new-account">Initializing a new account</a></h2>
<p>A new account can be initialized on-chain with a transaction:</p>
<ul>
<li>anything be written into its storage (initial parameter)</li>
<li>a validity predicate has to be provided (we can have a default out-of-band)</li>
<li>at minimum, accounts need to be enumerated on chain, this could be done with an address or a counter</li>
</ul>
<p>A newly created account should be validated by all the VPs triggered by the transaction, i.e. it should be included in the set of changed keys passed to each VP. If the VPs are not interested in the newly created account, they can choose to ignore it.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="validity-predicates"><a class="header" href="#validity-predicates">Validity predicates</a></h1>
<p><a href="https://github.com/anoma/anoma/issues/44">Tracking Issue</a></p>
<hr />
<p>Each <a href="explore/design/ledger/accounts.html">account</a> is associated with exactly one validity predicate (VP).</p>
<p>Conceptually, a VP is a function from the transaction's data and the storage state prior and posterior to a transaction execution returning a boolean value. A transaction may modify any data in the <a href="explore/design/ledger/accounts.html#dynamic-storage-sub-space">accounts' dynamic storage sub-space</a>. Upon <a href="explore/design/ledger/tx.html#tx-execution">transaction execution</a>, the VPs associated with the accounts whose storage has been modified are invoked to verify the transaction. If any of them reject the transaction, all of its storage modifications are discarded.</p>
<p>There are some native VPs for <a href="explore/design/ledger/accounts.html#internal-transparent-addresses">internal transparent addresses</a> that are built into the ledger. All the other VPs are implemented as <a href="explore/design/ledger/wasm-vm.html">WASM programs</a>. One can build a custom VP using the <a href="https://github.com/anoma/anoma/tree/master/wasm/vp_template">VP template</a> or use one of the pre-defined VPs.</p>
<p>The VPs must implement the following interface that will be invoked by the protocol:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn validate_tx(
    // Data of the transaction that triggered this VP call
    tx_data: Vec&lt;u8&gt;,
    // Address of this VP
    addr: Address,
    // Storage keys that have been modified by the transation, relevant to this VP
    keys_changed: BTreeSet&lt;storage::Key&gt;,
    // Set of all the addresses whose VP was triggered by the transaction
    verifiers: BTreeSet&lt;Address&gt;,
) -&gt; bool;
<span class="boring">}
</span></code></pre></pre>
<p>The host functions available to call from inside the VP code can be found in <a href="https://dev.anoma.net/master/rustdoc/anoma_vm_env/imports/vp/index.html#functions">docs generated from code</a>.</p>
<h2 id="native-vps"><a class="header" href="#native-vps">Native VPs</a></h2>
<p>The native VPs follow the same interface as WASM VPs and rules for how they are <a href="explore/design/ledger/tx.html#tx-execution">triggered by a transaction</a>. They can also call the same host functions as those provided in <a href="explore/design/ledger/wasm-vm.html#vps-environment">WASM VPs environment</a> and must also account any computation for gas usage.</p>
<h3 id="pos-slash-pool-vp"><a class="header" href="#pos-slash-pool-vp">PoS slash pool VP</a></h3>
<p>The Proof-of-Stake slash pool is a simple account with a native VP which can receive slashed tokens, but no token can ever be withdrawn from it by anyone at this point.</p>
<h2 id="fungible-token-vp"><a class="header" href="#fungible-token-vp">Fungible token VP</a></h2>
<p>The <a href="https://github.com/anoma/anoma/tree/master/wasm/wasm_source">fungible token VP</a> allows to associate accounts balances of a specific token under its account.</p>
<p>For illustration, users <code>Albert</code> and <code>Bertha</code> might hold some amount of token with the address <code>XAN</code>. Their balances would be stored in the <code>XAN</code>'s storage sub-space under the storage keys <code>@XAN/balance/@Albert</code> and <code>@XAN/balance/@Bertha</code>, respectively. When <code>Albert</code> or <code>Bertha</code> attempt to transact with their <code>XAN</code> tokens, its validity predicate would be triggered to check:</p>
<ul>
<li>the total supply of <code>XAN</code> token is preserved (i.e. inputs = outputs)</li>
<li>the senders (users whose balance has been deducted) are checked that their validity predicate has also been triggered</li>
</ul>
<p>Note that the fungible token VP doesn't need to know whether any of involved users accepted or rejected the transaction, because if any of the involved users rejects it, the whole transaction will be rejected.</p>
<h2 id="user-vp"><a class="header" href="#user-vp">User VP</a></h2>
<p>The <a href="https://github.com/anoma/anoma/blob/master/wasm/wasm_source/src/vp_user.rs">user VP</a> currently provides a signature verification against a public key for sending tokens as prescribed by the fungible token VP. In this VP, a transfer of tokens doesn't have to be authorized by the receiving party.</p>
<p>It also allows arbitrary storage modifications to the user's sub-space to be performed by a transaction that has been signed by the secret key corresponding to the user's public key stored on-chain. This functionality also allows one to update their own validity predicate.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="transactions"><a class="header" href="#transactions">Transactions</a></h1>
<p><a href="https://github.com/anoma/anoma/issues/43">Tracking Issue</a></p>
<hr />
<p>There is only a single general transaction (tx) type:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Transaction {
    // A wasm module with a required entrypoint
    code: Vec&lt;u8&gt;
    // Optional arbitrary data
    data: Option&lt;Vec&lt;u8&gt;&gt;,
    // A timestamp of when the transaction was created
    timestamp: Timestamp,
    gas_limit: TODO,
}
<span class="boring">}
</span></code></pre></pre>
<p>The tx allows to include arbitrary <code>data</code>, e.g zero-knowledge proofs and/or arbitrary nonce bytes to obfuscate the tx's minimum encoded size that may be used to derive some information about the tx.</p>
<p>TODO once we have DKG, we will probably want to have some kind of a wrapper transaction with submission fees, payer and signature</p>
<h2 id="tx-life-cycle"><a class="header" href="#tx-life-cycle">Tx life cycle</a></h2>
<pre class="mermaid">flowchart TD
    subgraph Node
    I[Initialize chain] --&gt; Begin
    Begin[Begin block] --&gt; Poll
    Poll[Poll mempool queue] --&gt; Apply
    Apply[Apply txs] --&gt; End
    End[End block] --&gt; Commit[Commit block]
    Commit --&gt; Begin
    Commit --&gt; Flush
      subgraph Mempool
      Validate --&gt; V{is valid?}
      V --&gt;|Yes| Add[Add to local queue]
      V --&gt;|No| Fail[Drop tx]
      Flush --&gt;|Re-validate txs not included in this block| V
      end
    end
    subgraph Client
    Submit[Submit tx] --&gt; Validate
    end
</pre>
<p>New txs are injected by the client via mempool. Before including a tx in a local mempool queue, some cheap validation may be performed. Once a tx is included in a mempool queue, it will be gossiped with the peers and may be included in a block by the block proposer. Any txs that are left in the queue after flush will be subject to re-validation before being included again.</p>
<p>The order of applying transactions within a block is fixed by the block proposer in <a href="explore/design/ledger/front-running.html">the front-running prevention protocol</a>.</p>
<p>TODO we might want to randomize the tx order after DKG protocol is completed</p>
<h3 id="block-application"><a class="header" href="#block-application">Block application</a></h3>
<p>Within a block, each tx is applied sequentially in three steps:</p>
<pre class="mermaid">flowchart TD
    B[Begin block] --&gt; N{Has next tx and within block gas limit?}
    N --&gt; |Yes|E
    N -----&gt; |No|EB[End block]
    E[Exec tx code] --&gt;|&quot;∀ accounts with modified storage&quot;| VP[Run validity predicates in parallel]
    VP --&gt; A{all accept}
    A --&gt; |No|R[Reject tx]
    A --&gt; |Yes|C[Commit tx and state changes]
    R --&gt; N
    C --&gt; N

</pre>
<h2 id="tx-execution"><a class="header" href="#tx-execution">Tx execution</a></h2>
<p>The code is allowed to read and write anything from <a href="explore/design/ledger/./accounts.html#dynamic-storage-sub-space">accounts' sub-spaces</a> and to <a href="explore/design/ledger/./accounts.html#initializing-a-new-account">initialize new accounts</a>. Other data that is not in an account's subspace is read-only, e.g. chain and block metadata, account addresses and potentially keys.</p>
<p>In addition to the verifiers specified in a transaction, each account whose sub-space has been modified by the tx triggers its VP.</p>
<p>For <a href="explore/design/ledger/accounts.html#internal-transparent-addresses">internal addresses</a>, we invoke their module's native VP interface directly. For other addresses, we look-up validity predicates WASM to be executed from storage.</p>
<p>The VPs are then given the prior and posterior state from the account's sub-space together with the tx to decide if it accepts the tx's state modifications.</p>
<p>Within a single tx the execution of the validity predicates will be parallelized and thus the fee for VPs execution would their maximum value (plus some portion of the fees for each of the other parallelized VPs - nothing should be &quot;free&quot;). Once any of the VPs rejects the modifications, execution is aborted, the transaction is rejected and state changes discarded. If all the VPs accept the modifications, the transaction is successful and modifications are committed to storage as the input of the next tx.</p>
<p>The transaction's API should make it possible to transfer tokens to a hash of a public key that is not revealed. This could be done by having a &quot;deposit&quot; account from which the key's owner can claim the deposited funds.</p>
<p>Should some type of token prefer not to allow to receive tokens without recipient's approval, a token account can implement logic to decline the received tokens.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasm-vm"><a class="header" href="#wasm-vm">WASM VM</a></h1>
<p>A wasm virtual machine will be used for <a href="explore/design/ledger/./vp.html">validity predicates</a> and <a href="explore/design/ledger/./tx.html">transactions code</a>. </p>
<p>The VM should provide:</p>
<ul>
<li>an interface for compiling from higher-level languages to wasm (initially only Rust)</li>
<li>a wasm compiler, unless we use <a href="explore/design/ledger/../../libraries/wasm.html">an interpreted runtime</a></li>
<li>provide and inject <a href="explore/design/ledger/wasm-vm.html#wasm-environment">environments for higher-level languages for VPs and transactions</a></li>
<li>pre-process wasm modules
<ul>
<li>check &amp; sanitize modules</li>
<li>inject gas metering</li>
<li>inject stack height metering</li>
</ul>
</li>
<li>a runner for VPs and transaction code</li>
<li>encode/decode wasm for transfer &amp; storage</li>
<li><a href="explore/design/ledger/wasm-vm.html#wasm-memory">manage runtime memory</a></li>
<li>wasm development helpers</li>
<li>helpers to estimate gas usage</li>
<li>VM and environment versioning</li>
</ul>
<h2 id="resources"><a class="header" href="#resources">Resources</a></h2>
<ul>
<li><a href="https://webassembly.github.io/spec/">WebAssembly Specifications</a></li>
<li><a href="https://docs.wasmer.io/integrations/examples">wasmer examples</a></li>
<li><a href="https://github.com/webassembly/wabt/">The WebAssembly Binary Toolkit</a>
<ul>
<li>bunch of useful wasm tools (e.g. <code>wasm2wat</code> to convert from wasm binary to human-readable wat format) </li>
</ul>
</li>
<li><a href="https://github.com/rustwasm/team">Rust wasm WG</a> and <a href="https://rustwasm.github.io/book/introduction.html">wasm book</a> (some sections are JS specific)</li>
<li><a href="https://radu-matei.com/blog/practical-guide-to-wasm-memory/">A practical guide to WebAssembly memory</a> modulo JS specific details</li>
<li><a href="https://learnxinyminutes.com/docs/wasm/">Learn X in Y minutes Where X=WebAssembly</a></li>
</ul>
<h2 id="wasm-environment"><a class="header" href="#wasm-environment">Wasm environment</a></h2>
<p>The wasm environment will most likely be libraries that provide APIs for the wasm modules.</p>
<h3 id="common-environment"><a class="header" href="#common-environment">Common environment</a></h3>
<p>The common environment of VPs and transactions APIs:</p>
<ul>
<li>math &amp; crypto</li>
<li>logging</li>
<li>panics/aborts</li>
<li>gas metering</li>
<li>storage read-only API</li>
<li>context API (chain metadata such as block height)</li>
</ul>
<p>The accounts sub-space storage is described under <a href="explore/design/ledger/./accounts.html#dynamic-storage-sub-space">accounts' dynamic storage sub-space</a>.</p>
<h3 id="vps-environment"><a class="header" href="#vps-environment">VPs environment</a></h3>
<p>Because VPs are stateless, everything that is exposed in the VPs environment should be read-only:</p>
<ul>
<li>storage API to account sub-space the <a href="explore/design/ledger/wasm-vm.html#storage-write-log">storage write log</a></li>
<li>transaction API</li>
</ul>
<h3 id="transactions-environment"><a class="header" href="#transactions-environment">Transactions environment</a></h3>
<ul>
<li>storage write access for all public state via the <a href="explore/design/ledger/wasm-vm.html#storage-write-log">storage write log</a></li>
</ul>
<p>Some exceptions as to what can be written are given under <a href="explore/design/ledger/./tx.html#tx-execution">transaction execution</a>.</p>
<h2 id="wasm-memory"><a class="header" href="#wasm-memory">Wasm memory</a></h2>
<p>The wasm memory allows to share data bi-directionally between the host (Rust shell) and the guest (wasm) through a <a href="https://webassembly.github.io/spec/core/exec/runtime.html#syntax-meminst">wasm linear memory instance</a>.</p>
<p>Because <a href="https://webassembly.github.io/spec/core/syntax/types.html">wasm currently only supports basic types</a>, we need to choose how to represent more sophisticated data in memory.</p>
<p>The options on how the data can be passed through the memory are:</p>
<ul>
<li>using <a href="https://doc.rust-lang.org/nomicon/other-reprs.html#reprc">&quot;C&quot; structures</a> (probably too invasive because everything in memory would have to use C repr)</li>
<li>(de)serializing the data with some encoding (JSON, binary, ...?)</li>
<li>currently very unstable: <a href="https://developer.mozilla.org/en-US/docs/Glossary/WebIDL">WebIDL</a> / <a href="https://github.com/WebAssembly/interface-types/blob/master/proposals/interface-types/Explainer.md">Interface Types</a> / <a href="https://github.com/WebAssembly/reference-types">Reference types</a></li>
</ul>
<p>The choice should allow for easy usage in wasm for users (e.g. in Rust a bindgen macro on data structures, similar to <a href="https://github.com/rustwasm/wasm-bindgen">wasm_bindgen used for JS &lt;-&gt; wasm</a>).</p>
<p>Related <a href="https://github.com/wasmerio/wasmer/issues/315">wasmer issue</a>.</p>
<p>We're currently using borsh for storage serialization, which is also a good option for wasm memory. </p>
<ul>
<li>it's easy for users (can be derived)</li>
<li>because borsh encoding is safe and consistent, the encoded bytes can also be used for Merkle tree hashing</li>
<li>good performance, although it's not clear at this point if that may be negligible anyway</li>
</ul>
<h3 id="the-data"><a class="header" href="#the-data">The data</a></h3>
<p>The data being passed between the host and the guest in the order of the execution:</p>
<ul>
<li>For transactions:
<ul>
<li>host-to-guest: pass tx.data to tx.code call</li>
<li>guest-to-host: parameters of environment functions calls, including storage modifications (pending on storage API)</li>
<li>host-to-guest: return results for host calls</li>
</ul>
</li>
<li>For validity predicates:
<ul>
<li>host-to-guest: pass tx.data, prior and posterior account storage sub-space state and/or storage modifications (i.e. a write log) for the account</li>
<li>guest-to-host: parameters of environment function calls</li>
<li>host-to-guest: return results for host calls</li>
<li><del>guest-to-host</del>: the VP result (<code>bool</code>) can be passed directly from the call</li>
</ul>
</li>
</ul>
<h3 id="storage-write-log"><a class="header" href="#storage-write-log">Storage write log</a></h3>
<p>The storage write log gathers any storage updates (<code>write</code>/<code>delete</code>s) performed by transactions. For each transaction, the write log changes must be accepted by all the validity predicates that were triggered by these changes.</p>
<p>A validity predicate can read its prior state directly from storage as it is not changed by the transaction directly. For the posterior state, we first try to look-up the keys in the write log to try to find a new value if the key has been modified or deleted. If the key is not present in the write log, it means that the value has not changed and we can read it from storage.</p>
<p>The write log of each transaction included in a block and accepted by VPs is accumulated into the block write log. Once the block is committed, we apply the storage changes from the block write log to the persistent storage.</p>
<p><img src="explore/design/ledger/./wasm-vm/storage-write-log.svg" alt="write log" title="storage write log" />
<a href="https://excalidraw.com/new#room=333e1db689b083669c80,Y0i8yhvIAZCFICs753CSuA">Diagram on Excalidraw</a></p>
<h2 id="gas-metering"><a class="header" href="#gas-metering">Gas metering</a></h2>
<p>The two main options for implementing gas metering within wasm using wasmer are:</p>
<ul>
<li>a <a href="https://github.com/wasmerio/wasmer/tree/72d47336cc1461d63baa2322b38c4cb5f67bb72a/lib/middlewares">gas metering middleware included in wasmer</a>.</li>
<li><a href="https://crates.io/crates/pwasm-utils">https://crates.io/crates/pwasm-utils</a></li>
</ul>
<p>Both of these allow us to assign a gas cost for each wasm operation.</p>
<p><code>wasmer</code> gas middleware is more recent, so probably more risky. It injects the gas metering code into the wasm code, which is more efficient than host calls to a gas meter.</p>
<p><code>pwasm-utils</code> divides the wasm code into metered blocks. It performs host call with the gas cost of each block before it is executed. The gas metering injection is linear to the code size.</p>
<p>The <code>pwasm-utils</code> seems like a safer option to begin with (and we'll probably need to use it for <a href="explore/design/ledger/wasm-vm.html#stack-height-metering">stack height metering</a> too). We can look into switching to <code>wasmer</code> middleware at later point.</p>
<h2 id="stack-height-metering"><a class="header" href="#stack-height-metering">Stack height metering</a></h2>
<p>For safety, we need to limit the stack height in wasm code. Similarly to gas metering, we can also use <code>wasmer</code> middleware or <code>pwasm-utils</code>.</p>
<p>We have to use <code>pwasm-utils</code>, because <code>wasmer</code>'s stack limiter is currently non-deterministic (platform specific). This is to be fixed in this PR: <a href="https://github.com/wasmerio/wasmer/pull/1037">https://github.com/wasmerio/wasmer/pull/1037</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="front-running-prevention"><a class="header" href="#front-running-prevention">Front-running prevention</a></h1>
<p><a href="https://github.com/anoma/anoma/issues/42">Tracking Issue</a></p>
<hr />
<p>This page should describe how DKG can be integrated for front-running prevention.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fractal-scaling"><a class="header" href="#fractal-scaling">Fractal scaling</a></h1>
<p><a href="https://github.com/anoma/anoma/issues/41">Tracking Issue</a></p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="upgrade-system"><a class="header" href="#upgrade-system">Upgrade system</a></h1>
<p><a href="https://github.com/anoma/anoma/issues/40">Tracking Issue</a></p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="storage"><a class="header" href="#storage">Storage</a></h1>
<p>By default, we persist all the historical data for the predecessor blocks to be able to replay the whole chain and to be able to support Tendermint's rollback command (that allows to rollback the state to the predecessor block, which is useful recovering from a corrupt state). For values that change on every block, we can simply prefix their storage key with the block height.</p>
<p>However, for the accounts storage it is reasonable to expect that in each block only a small subset of the data will be updated, so we can avoid persisting values that haven't changed from the predecessor block. To achieve that:</p>
<ul>
<li>The latest value is written into and read from its storage key without any height prefix</li>
<li>If the previous value is overwritten or deleted at block height <code>n</code>, we store the diff (old and new value) under <code>n</code> prefix (the height at which it's been changed from this value)</li>
</ul>
<p>Note that when there are multiple updates of a value with the same storage key in the same block, only the last value will be persisted to the block.</p>
<p>The block's mutable metadata is permanently in-memory and batch written to DB once a block is finalized.</p>
<pre class="mermaid">graph LR
  subgraph &quot;in-memory&quot;
    LN[level n]
  end
  subgraph &quot;DB (each level is immutable once written)&quot;
    LN .-&gt; LNL[level n - 1]
    LNL ===== L0[level 0]
  end
</pre>
<p>The accounts storage data are written and read directly to/from the DB and the DB layer manages its cache.</p>
<h2 id="in-memory-mutable-state"><a class="header" href="#in-memory-mutable-state">In-memory (mutable state)</a></h2>
<p>The current state is stored in a Sparse Merkle tree. The layout of data in memory should be flexible to allow to optimize throughput. For example, the values of key/value pairs may better stored in a sequence outside of the tree structure. Furthermore, it maybe be better to have the data sorted in memory. This may be possible by decoupling the merkle tree structure from the data and the key/value pairs, as illustrated below.</p>
<pre class="mermaid">graph TD
  subgraph storage
    subgraph sparse merkle tree
      B[branches as paths segments in hashes of keys] .-&gt; L[leaves as a hashes of values]
    end
    subgraph columns
      KV[dictionaries of key/value pairs]
    end
  end
</pre>
<p>It may be advantageous if the data columns keys are not hashed to preserve ordering.</p>
<h2 id="db-immutable-state"><a class="header" href="#db-immutable-state">DB (immutable state)</a></h2>
<p>The immutable state doesn't have the same requirements as the mutable. This means that a different data structures or memory layout may perform better (subject to benchmarks). The state trees in the immutable blocks should take advantage of its properties for optimization. For example, it can save storage space by sharing common data and/or delta compression.</p>
<p>It's very likely that different settings for immutable storage will be provided in future, similar to e.g. <a href="https://tezos.gitlab.io/user/history_modes.html">Tezos history modes</a>.</p>
<h2 id="benchmarks"><a class="header" href="#benchmarks">Benchmarks</a></h2>
<p>We'd like to have easily reproducible benchmarks for the whole database integration that should be filled over time with pre-generated realistic data. This should enable us to tune and compare different hashing functions, backends, data structures, memory layouts, etc.</p>
<h3 id="criteria"><a class="header" href="#criteria">Criteria</a></h3>
<ul>
<li>in-memory
<ul>
<li>writes (insert, update, delete)
<ul>
<li>possibly also concurrent writes, pending on the approach taken for concurrent transaction execution</li>
</ul>
</li>
<li>reads</li>
<li>proof generation (inclusion, non-inclusion)</li>
</ul>
</li>
<li>DB (lower priority)
<ul>
<li>writes in batched mode</li>
<li>reads</li>
<li>proof generation (inclusion, non-inclusion)</li>
</ul>
</li>
</ul>
<h2 id="db-backends"><a class="header" href="#db-backends">DB backends</a></h2>
<p>The considered options for a DB backend are given in <a href="explore/design/ledger/../../libraries/db.html">Libraries &amp; Tools / Database page</a>.</p>
<h3 id="rocksdb"><a class="header" href="#rocksdb">RocksDB</a></h3>
<p>A committed block is not immediately persisted on RocksDB. When the block is committed, a set of key-value pairs which compose the block is written to the memtable on RocksDB. For the efficient sequential write, a flush is executed to persist the data on the memtable to the disk as a file when the size of the memtable is getting big (the threshold is one of the tuning parameters).</p>
<p>We can disable write-ahead log(WAL) which protects these data on the memtable from a crash by persisting the write logs to the disk. Disabling WAL helps reduce the write amplification. That's because WAL isn't required for Anoma because other nodes have the block. The blocks which have not been persisted to the disk by flush can be recovered even if an Anoma node crashes.</p>
<h2 id="implementation"><a class="header" href="#implementation">Implementation</a></h2>
<h3 id="storage-module"><a class="header" href="#storage-module"><code>storage</code> module</a></h3>
<p>This is the main interface for interacting with storage in Anoma.</p>
<p>This module and its sub-modules should implement the in-memory storage (and/or a cache layer) with Merkle tree (however, the interface should be agnostic to the choice of vector commitment scheme or whether or not there even is one, we may want non-Merklised storage) and the persistent DB.</p>
<p>The in-memory storage holds chain's metadata and current block's storage.</p>
<p>Its public API should allow/provide:</p>
<ul>
<li>get the Merkle root and Merkle tree proofs</li>
<li>read-only storage API for ledger's metadata to be accessible for transactions' code, VPs and the RPC
<ul>
<li>with public types of all the stored metadata</li>
</ul>
</li>
<li>unless specified otherwise, read the state from the current block</li>
</ul>
<p>An API made visible only to the shell module (e.g. <code>pub ( in SimplePath )</code> - https://doc.rust-lang.org/reference/visibility-and-privacy.html) should allow the shell to:</p>
<ul>
<li>load state from DB for latest persisted block or initialize a new storage if none found</li>
<li>begin a new block</li>
<li>within a block:
<ul>
<li>transaction can modify <a href="explore/design/ledger/accounts.html#dynamic-storage-sub-space">account sub-space</a>
<ul>
<li>the function that modify storage (e.g. <code>write</code> and <code>delete</code>) have to guarantee to also update the Merkle tree</li>
</ul>
</li>
<li>store each applied transaction and its result</li>
</ul>
</li>
<li>end the current block</li>
<li>commit the current block (persist to storage)</li>
</ul>
<h3 id="storagemerkle_tree-module"><a class="header" href="#storagemerkle_tree-module"><code>storage/merkle_tree</code> module</a></h3>
<p>It consists of one Sparse Merkle Tree (base tree) and multiple Sparse Merkle Trees (subtrees). The base tree stores the store type and the root of each subtree as a key-value pair. Each subtree has the hashed key-value pairs for each data.</p>
<pre class="mermaid">graph TD
  subgraph &quot;Merkle tree&quot;
    subgraph &quot;Base tree&quot;
      R[Root] --&gt; I0
      R --&gt; I1
      I0 --&gt; L0[Subtree 0]
      I0 --&gt; L1[Subtree 1]
      I1 --&gt; L2[Subtree 2]
      I1 --&gt; L3[Subtree 3]
    end
    subgraph &quot;Subtree 1&quot;
      L1 --&gt; SR[Subroot]
      SR --&gt; SI0
      SR --&gt; SI1
      SI0 --&gt; SI00
      SI0 --&gt; SI01
      SI1 --&gt; SI10
      SI1 --&gt; SI11
      SI00 --&gt; SL000
      SI00 --&gt; SL001
      SI01 --&gt; SL010
      SI01 --&gt; SL011
      SI10 --&gt; SL100
      SI10 --&gt; SL101
      SI11 --&gt; SL110
      SI11 --&gt; SL111
    end
  end
</pre>
<p>The first segment of a <a href="explore/design/ledger/storage.html#db-keys">DB key</a> is used as a key in the base tree and the sub key (without the first segment) specifies the leaf of the subtree.</p>
<p>A proof of the key-value pair in the Merkle tree should be made of two proofs for the base tree and the subtree. Merkle root is the root of the base tree. In the proof verification, the sub root is calculated with the subtree's proof at first. Then, the root is calculated with the base tree's proof and the calculated sub root as a value, and the calculated root is compared with the Merkle root.</p>
<h3 id="storagedb-module"><a class="header" href="#storagedb-module"><code>storage/db</code> module</a></h3>
<p>The persistent DB implementation (e.g. RocksDB).</p>
<h3 id="db-keys"><a class="header" href="#db-keys">DB keys</a></h3>
<p>The DB keys are composed of key segments. A key segment can be an <code>Address</code> which starts with <code>#</code> (there can be multiple addresses involved in a key) or any user defined non-empty utf-8 string (maybe limited to only alphanumerical characters). Also, <code>/</code> and <code>?</code> are reserved. <code>/</code> is used as a separator for segments. <code>?</code> is reserved for a validity predicate and the key segment <code>?</code> can be specified only by the specific API.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-schema"><a class="header" href="#data-schema">Data schema</a></h1>
<p>At high level, all the data in the <a href="explore/design/ledger/storage/../accounts.html#dynamic-storage-sub-space">accounts' dynamic
sub-spaces</a> is just keys associated with
arbitrary bytes and intents are just wrapper around arbitrary data. To help the
processes that read and write this data (transactions, validity predicates,
matchmaker) interpret it and implement interesting functionality on top it, the
ledger could provide a way to describe the schema of the data.</p>
<p>For storage data encoding, we're currently using the borsh library, which
provides a way to derive schema for data that can describe its structure in a
very generic way that can easily be consumed in different data-exchange formats
such as JSON. In Rust code, the data can be composed with Rust native ADTs
(<code>struct</code> and <code>enum</code>) and basic collection structures (fixed and dynamic sized
array, hash map, hash set). Borsh already has a decent coverage of different
implementations in e.g. JS and TypeScript, JVM based languages and Go, which
we'll hopefully be able to support in wasm in near future too.</p>
<p>Note that the borsh data schema would not be forced upon the users as they can
still build and use custom data with arbitrary encoding.</p>
<p>A naive implementation could add optional <code>schema</code> field to each stored key. To
reduce redundancy, there could be some &quot;built-in&quot; schemas and/or specific
storage space for commonly used data schema definitions. Storage fees apply, but
perhaps they can be split between all the users, so some commonly used data
schema may be almost free.</p>
<p>A single address in the ledger is define with all schema. A specific schema can
be looked up with a key in its subspace. The schema variable is not yet
implemented and the definition might change to something more appropiate.</p>
<h2 id="schema-derived-library-code"><a class="header" href="#schema-derived-library-code">Schema derived library code</a></h2>
<h3 id="account-example"><a class="header" href="#account-example">account example</a></h3>
<p>Let's start with an example, in which some users want to deploy a
multi-signature account to some shared asset. They create a transaction, which
would initialize a new account with an address <code>shared-savings</code> and write into
its storage sub-space the initial funds for the account and data under the key
<code>&quot;multisig&quot;</code> with the following definition:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Schema)]
struct MultiSig {
    threshold: u64,
    counter: u64,
    keys: Vec&lt;PublicKey&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>When the transaction is applied, the data is stored together with a reference to
the derived data schema, e.g.:</p>
<pre><code class="language-json">{
  &quot;MultiSig&quot;: {
    &quot;struct&quot;: {
      &quot;named_fields&quot;: {
        &quot;threshold&quot;: &quot;u64&quot;,
        &quot;counter&quot;: &quot;u64&quot;,
        &quot;keys&quot;: {
          &quot;sequence&quot;: &quot;PublicKey&quot;
        }
      }
    }
  }
}
</code></pre>
<p>Now any transaction that wants to interact with this account can look-up and use its data schema. We can also use this information to display values read from storage from e.g. RPC or indexer.</p>
<p>What's more, when the data has schema attached on-chain, with borsh we have bijective mapping between the data definitions and their schemas. We can use this nice property to generate code for data definitions back from the schema in any language supported by borsh and that we'll able to support in wasm.</p>
<p>We can take this a step further and even generate some code for data access on top of our wasm environment functions to lift the burden of encoding/decoding data from storage. For our example, from the key <code>&quot;multisig&quot;</code>, in Rust we can generate this code:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn read_multisig() -&gt; MultiSig;
fn write_multisig(MultiSig);
fn with_multisig(FnMut(MultiSig) -&gt; MultiSig);
<span class="boring">}
</span></code></pre></pre>
<p>Which can be imported like regular library code in a transaction and arbitrarily extended by the users. Similarly, the schema could be used to derive some code for validity predicates and intents.</p>
<p>We can generate the code on demand (e.g. we could allow to query a node to generate library code for some given accounts for a given language), but we could also provide some helpers for e.g. foundation's or validator's node to optionally automatically publish generated code via git for all the accounts in the current state. In Rust, using this library could look like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// load the account(s) code where the identifier is the account's address.
use anoma_accounts::SharedSavings;

fn transaction(...) {
  let multisig = SharedSavings::read_multisig();
  ...
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pos-integration"><a class="header" href="#pos-integration">PoS integration</a></h1>
<p>The <a href="explore/design/ledger/../pos.html">PoS system</a> is integrated into Anoma ledger at 3 different layers:</p>
<ul>
<li>base ledger that performs genesis initialization, validator set updates on new epoch and applies slashes when they are received from ABCI</li>
<li>an account with an internal address and a <a href="explore/design/ledger/vp.html#native-vps">native VP</a> that validates any changes applied by transactions to the PoS account state</li>
<li>transaction WASMs to perform various PoS actions, also available as a library code for custom made transactions</li>
</ul>
<p>The <code>votes_per_token</code> PoS system parameter must be chosen to satisfy the <a href="https://github.com/tendermint/spec/blob/60395941214439339cc60040944c67893b5f8145/spec/abci/apps.md#validator-updates">Tendermint requirement</a> of <code>MaxTotalVotingPower = MaxInt64 / 8</code>.</p>
<p>All <a href="explore/design/ledger/../pos.html#storage">the data relevant to the PoS system</a> are stored under the PoS account's storage sub-space, with the following key schema (the PoS address prefix is omitted for clarity):</p>
<ul>
<li>
<p><code>params</code> (required): the system parameters</p>
</li>
<li>
<p>for any validator, all the following fields are required:</p>
<ul>
<li><code>validator/{validator_address}/consensus_key</code></li>
<li><code>validator/{validator_address}/state</code></li>
<li><code>validator/{validator_address}/total_deltas</code></li>
<li><code>validator/{validator_address}/voting_power</code></li>
</ul>
</li>
<li>
<p><code>slash/{validator_address}</code> (optional): a list of slashes, where each record contains epoch and slash rate</p>
</li>
<li>
<p><code>bond/{bond_source}/{bond_validator} (optional)</code></p>
</li>
<li>
<p><code>unbond/{unbond_source}/{unbond_validator} (optional)</code></p>
</li>
<li>
<p><code>validator_set (required)</code></p>
</li>
<li>
<p><code>total_voting_power (required)</code></p>
</li>
<li>
<p>standard validator metadata (these are regular storage values, not epoched data):</p>
<ul>
<li><code>validator/{validator_address}/staking_reward_address</code> (required): an address that should receive staking rewards</li>
<li><code>validator/{validator_address}/address_raw_hash</code> (required): raw hash of validator's address associated with the address is used for look-up of validator address from a raw hash</li>
<li>TBA (e.g. alias, website, description, delegation commission rate, etc.)</li>
</ul>
</li>
</ul>
<p>Only XAN tokens can be staked in bonds. The tokens being staked (bonds and unbonds amounts) are kept in the PoS account under <code>{xan_address}/balance/{pos_address}</code> until they are withdrawn.</p>
<h2 id="initialization"><a class="header" href="#initialization">Initialization</a></h2>
<p>The PoS system is initialized via the shell on chain initialization. The genesis validator set is given in the genesis configuration. On genesis initialization, all the epoched data is set to be immediately active for the current (the very first) epoch.</p>
<h2 id="staking-rewards-and-transaction-fees"><a class="header" href="#staking-rewards-and-transaction-fees">Staking rewards and transaction fees</a></h2>
<p>Staking rewards for validators are rewarded in Tendermint's method <code>BeginBlock</code> in the base ledger. A validator must specify a <code>validator/{validator_address}/staking_reward_address</code> for its rewards to be credited to this address.</p>
<p>To a validator who proposed a block (<code>block.header.proposer_address</code>), the system rewards tokens based on the <code>block_proposer_reward</code> PoS parameter and each validator that voted on a block (<code>block.last_commit_info.validator</code> who <code>signed_last_block</code>) receives <code>block_vote_reward</code>.</p>
<p>All the fees that are charged in a transaction execution (DKG transaction wrapper fee and transactions applied in a block) are transferred into a fee pool, which is another special account controlled by the PoS module. Note that the fee pool account may contain tokens other than the staking token XAN.</p>
<ul>
<li>TODO describe the fee pool, related to <a href="https://github.com/anomanetwork/anoma/issues/48">https://github.com/anomanetwork/anoma/issues/48</a>, <a href="https://github.com/anomanetwork/anoma/issues/51">https://github.com/anomanetwork/anoma/issues/51</a> and <a href="https://github.com/anomanetwork/anoma/issues/72">https://github.com/anomanetwork/anoma/issues/72</a></li>
</ul>
<h2 id="transactions-1"><a class="header" href="#transactions-1">Transactions</a></h2>
<p>The transactions are assumed to be applied in epoch <code>n</code>. Any transaction that modifies <a href="explore/design/ledger/../pos.html#epoched-data">epoched data</a> updates the structure as described in <a href="explore/design/ledger/../pos.html#storage">epoched data storage</a>.</p>
<p>For slashing tokens, we implement a <a href="explore/design/ledger/vp.html#pos-slash-pool-vp">PoS slash pool account</a>. Slashed tokens should be credited to this account and, for now, no tokens can be be debited by anyone.</p>
<h3 id="validator-transactions"><a class="header" href="#validator-transactions">Validator transactions</a></h3>
<p>The validator transactions are assumed to be applied with an account address <code>validator_address</code>.</p>
<ul>
<li><code>become_validator(consensus_key, staking_reward_address)</code>:
<ul>
<li>creates a record in <code>validator/{validator_address}/consensus_key</code> in epoch <code>n + pipeline_length</code></li>
<li>creates a record in <code>validator/{validator_address}/staking_reward_address</code></li>
<li>sets <code>validator/{validator_address}/state</code> for to <code>pending</code> in the current epoch and <code>candidate</code> in epoch <code>n + pipeline_length</code></li>
</ul>
</li>
<li><code>deactivate</code>:
<ul>
<li>sets <code>validator/{validator_address}/state</code> for to <code>inactive</code> in epoch <code>n + pipeline_length</code></li>
</ul>
</li>
<li><code>reactivate</code>:
<ul>
<li>sets <code>validator/{validator_address}/state</code> for to <code>pending</code> in the current epoch and <code>candidate</code> in epoch <code>n + pipeline_length</code></li>
</ul>
</li>
<li><code>self_bond(amount)</code>:
<ul>
<li>let <code>bond = read(bond/{validator_address}/{validator_address}/delta)</code></li>
<li>if <code>bond</code> exist, update it with the new bond amount in epoch <code>n + pipeline_length</code></li>
<li>else, create a new record with bond amount in epoch <code>n + pipeline_length</code></li>
<li>debit the token <code>amount</code> from the <code>validator_address</code> and credit it to the PoS account</li>
<li>add the <code>amount</code> to <code>validator/{validator_address}/total_deltas</code> in epoch <code>n + pipeline_length</code></li>
<li>update the <code>validator/{validator_address}/voting_power</code> in epoch <code>n + pipeline_length</code></li>
<li>update the <code>total_voting_power</code> in epoch <code>n + pipeline_length</code></li>
<li>update <code>validator_set</code> in epoch <code>n + pipeline_length</code></li>
</ul>
</li>
<li><code>unbond(amount)</code>:
<ul>
<li>let <code>bond = read(bond/{validator_address}/{validator_address}/delta)</code></li>
<li>if <code>bond</code> doesn't exist, panic</li>
<li>let <code>pre_unbond = read(unbond/{validator_address}/{validator_address}/delta)</code></li>
<li>if <code>total(bond) - total(pre_unbond) &lt; amount</code>, panic</li>
<li>decrement the <code>bond</code> deltas starting from the rightmost value (a bond in a future-most epoch) until whole <code>amount</code> is decremented</li>
<li>for each decremented <code>bond</code> value write a new <code>unbond</code> with the key set to the epoch of the source value</li>
<li>decrement the <code>amount</code> from <code>validator/{validator_address}/total_deltas</code> in epoch <code>n + unbonding_length</code></li>
<li>update the <code>validator/{validator_address}/voting_power</code> in epoch <code>n + unbonding_length</code></li>
<li>update the <code>total_voting_power</code> in epoch <code>n + unbonding_length</code></li>
<li>update <code>validator_set</code> in epoch <code>n + unbonding_length</code></li>
</ul>
</li>
<li><code>withdraw_unbonds</code>:
<ul>
<li>let <code>unbond = read(unbond/{validator_address}/{validator_address}/delta)</code></li>
<li>if <code>unbond</code> doesn't exist, panic</li>
<li>if no <code>unbond</code> value is found for epochs &lt;= <code>n</code>, panic</li>
<li>for each <code>((bond_start, bond_end), amount) in unbond where unbond.epoch &lt;= n</code>:
<ul>
<li>let <code>amount_after_slash = amount</code></li>
<li>for each <code>slash in read(slash/{validator_address})</code>:
<ul>
<li>if <code>bond_start &lt;= slash.epoch &amp;&amp; slash.epoch &lt;= bond_end)</code>, <code>amount_after_slash *= (10_000 - slash.rate) / 10_000</code></li>
</ul>
</li>
<li>credit the <code>amount_after_slash</code> to the <code>validator_address</code> and debit the whole <code>amount</code> (before slash, if any) from the PoS account</li>
<li>burn the slashed tokens (<code>amount - amount_after_slash</code>), if not zero</li>
</ul>
</li>
</ul>
</li>
<li><code>change_consensus_key</code>:
<ul>
<li>creates a record in <code>validator/{validator_address}/consensus_key</code> in epoch <code>n + pipeline_length</code></li>
</ul>
</li>
</ul>
<p>For <code>self_bond</code>, <code>unbond</code>, <code>withdraw_unbonds</code>, <code>become_validator</code> and <code>change_consensus_key</code> the transaction must be signed with the validator's public key. Additionally, for <code>become_validator</code> and <code>change_consensus_key</code> we must attach a signature with the validator's consensus key to verify its ownership. Note that for <code>self_bond</code>, signature verification is also performed because there are tokens debited from the validator's account.</p>
<h3 id="delegator-transactions"><a class="header" href="#delegator-transactions">Delegator transactions</a></h3>
<p>The delegator transactions are assumed to be applied with an account address <code>delegator_address</code>.</p>
<ul>
<li><code>delegate(validator_address, amount)</code>:
<ul>
<li>let <code>bond = read(bond/{delegator_address}/{validator_address}/delta)</code></li>
<li>if <code>bond</code> exist, update it with the new bond amount in epoch <code>n + pipeline_length</code></li>
<li>else, create a new record with bond amount in epoch <code>n + pipeline_length</code></li>
<li>debit the token <code>amount</code> from the <code>delegator_address</code> and credit it to the PoS account</li>
<li>add the <code>amount</code> to <code>validator/{validator_address}/total_deltas</code> in epoch <code>n + pipeline_length</code></li>
<li>update the <code>validator/{validator_address}/voting_power</code> in epoch <code>n + pipeline_length</code></li>
<li>update the <code>total_voting_power</code> in epoch <code>n + pipeline_length</code></li>
<li>update <code>validator_set</code> in epoch <code>n + pipeline_length</code></li>
</ul>
</li>
<li><code>undelegate(validator_address, amount)</code>:
<ul>
<li>let <code>bond = read(bond/{delegator_address}/{validator_address}/delta)</code></li>
<li>if <code>bond</code> doesn't exist, panic</li>
<li>let <code>pre_unbond = read(unbond/{delegator_address}/{validator_address}/delta)</code></li>
<li>if <code>total(bond) - total(pre_unbond) &lt; amount</code>, panic</li>
<li>decrement the <code>bond</code> deltas starting from the rightmost value (a bond in a future-most epoch) until whole <code>amount</code> is decremented</li>
<li>for each decremented <code>bond</code> value write a new <code>unbond</code> with the key set to the epoch of the source value</li>
<li>decrement the <code>amount</code> from <code>validator/{validator_address}/total_deltas</code> in epoch <code>n + unbonding_length</code></li>
<li>update the <code>validator/{validator_address}/voting_power</code> in epoch <code>n + unbonding_length</code></li>
<li>update the <code>total_voting_power</code> in epoch <code>n + unbonding_length</code></li>
<li>update <code>validator_set</code> in epoch <code>n + unbonding_length</code></li>
</ul>
</li>
<li><code>redelegate(src_validator_address, dest_validator_address, amount)</code>:
<ul>
<li><code>undelegate(src_validator_address, amount)</code></li>
<li><code>delegate(dest_validator_address, amount)</code> but set in epoch <code>n + unbonding_length</code> instead of <code>n + pipeline_length</code></li>
</ul>
</li>
<li><code>withdraw_unbonds</code>:
<ul>
<li>for each <code>validator_address in iter_prefix(unbond/{delegator_address})</code>:
<ul>
<li>let <code>unbond = read(unbond/{validator_address}/{validator_address}/delta)</code></li>
<li>if no <code>unbond</code> value is found for epochs &lt;= <code>n</code>, <code>continue</code> to the next <code>validator_address</code></li>
<li>for each <code>((bond_start, bond_end), amount)</code> in epochs &lt;= <code>n</code>:
<ul>
<li>let <code>amount_after_slash = amount</code></li>
<li>for each <code>slash in read(slash/{validator_address})</code>:
<ul>
<li>if <code>bond_start &lt;= slash.epoch &amp;&amp; slash.epoch &lt;= bond_end)</code>, <code>amount_after_slash *= (10_000 - slash.rate) / 10_000</code></li>
</ul>
</li>
<li>credit the <code>amount_after_slash</code> to the <code>delegator_address</code> and debit the whole <code>amount</code> (before slash, if any) from the PoS account</li>
<li>burn the slashed tokens (<code>amount - amount_after_slash</code>), if not zero</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>For <code>delegate</code>, <code>undelegate</code>, <code>redelegate</code> and <code>withdraw_unbonds</code> the transaction must be signed with the delegator's public key. Note that for <code>delegate</code>, signature verification is also performed because there are tokens debited from the delegator's account.</p>
<h2 id="slashing"><a class="header" href="#slashing">Slashing</a></h2>
<p>Evidence for byzantine behaviour is received from Tendermint ABCI on <code>BeginBlock</code>. For each evidence:</p>
<ul>
<li>append the <code>evidence</code> into <code>slash/{evidence.validator_address}</code></li>
<li>calculate the slashed amount from deltas in and before the <code>evidence.epoch</code> in <code>validator/{validator_address}/total_deltas</code> for the <code>evidence.validator_address</code> and the slash rate</li>
<li>deduct the slashed amount from the <code>validator/{validator_address}/total_deltas</code> at <code>pipeline_length</code> offset</li>
<li>update the <code>validator/{validator_address}/voting_power</code> for the <code>evidence.validator_address</code> in and after epoch <code>n + pipeline_length</code></li>
<li>update the <code>total_voting_power</code> in and after epoch <code>n + pipeline_length</code></li>
<li>update <code>validator_set</code> in and after epoch <code>n + pipeline_length</code></li>
</ul>
<h2 id="validity-predicate"><a class="header" href="#validity-predicate">Validity predicate</a></h2>
<p>In the following description, &quot;pre-state&quot; is the state prior to transaction execution and &quot;post-state&quot; is the state posterior to it.</p>
<p>Any changes to PoS epoched data are checked to update the structure as described in <a href="explore/design/ledger/../pos.html#storage">epoched data storage</a>.</p>
<p>Because some key changes are expected to relate to others, the VP also accumulates some values that are checked for validity after key specific logic:</p>
<ul>
<li><code>balance_delta: token::Change</code></li>
<li><code>bond_delta: HashMap&lt;Address, token::Change&gt;</code></li>
<li><code>unbond_delta: HashMap&lt;Address, token::Change&gt;</code></li>
<li><code>total_deltas: HashMap&lt;Address, token::Change&gt;</code></li>
<li><code>total_stake_by_epoch: HashMap&lt;Epoch, HashMap&lt;Address, token::Amount&gt;&gt;</code></li>
<li><code>expected_voting_power_by_epoch: HashMap&lt;Epoch, HashMap&lt;Address, VotingPower&gt;&gt;</code>: calculated from the validator's total deltas</li>
<li><code>expected_total_voting_power_delta_by_epoch: HashMap&lt;Epoch, VotingPowerDelta&gt;</code>: calculated from the validator's total deltas</li>
<li><code>voting_power_by_epoch: HashMap&lt;Epoch, &lt;HashMap&lt;Address, VotingPower&gt;&gt;</code></li>
<li><code>validator_set_pre: Option&lt;ValidatorSets&lt;Address&gt;&gt;</code></li>
<li><code>validator_set_post: Option&lt;ValidatorSets&lt;Address&gt;&gt;</code></li>
<li><code>total_voting_power_delta_by_epoch: HashMap&lt;Epoch, VotingPowerDelta&gt;</code></li>
<li><code>new_validators: HashMap&lt;Address, NewValidator&gt;</code></li>
</ul>
<p>The accumulators are initialized to their default values (empty hash maps and hash set). The data keyed by address are using the validator addresses.</p>
<p>For any updated epoched data, the <code>last_update</code> field must be set to the current epoch.</p>
<p>The validity predicate triggers a validation logic based on the storage keys modified by a transaction:</p>
<ul>
<li><code>validator/{validator_address}/consensus_key</code>:
<pre><code class="language-rust ignore">match (pre_state, post_state) {
  (None, Some(post)) =&gt; {
    // - check that all other required validator fields have been initialized
    // - check that the `state` sub-key for this validator address has been set
    // correctly, i.e. the value should be initialized at `pipeline_length` offset
    // - insert into or update `new_validators` accumulator
  },
  (Some(pre), Some(post)) =&gt; {
    // - check that the new consensus key is different from the old consensus
    // key and that it has been set correctly, i.e. the value can only be changed at `pipeline_length` offset
  },
  _ =&gt; false,
}
</code></pre>
</li>
<li><code>validator/{validator_address}/state</code>:
<pre><code class="language-rust ignore">match (pre_state, post_state) {
  (None, Some(post)) =&gt; {
    // - check that all other required validator fields have been initialized
    // - check that the `post` state is set correctly:
    //   - the state should be set to `pending` in the current epoch and `candidate` at pipeline offset
    // - insert into or update `new_validators` accumulator
  },
  (Some(pre), Some(post)) =&gt; {
    // - check that a validator has been correctly deactivated or reactivated
    // - the `state` should only be changed at `pipeline_length` offset
    // - if the `state` becomes `inactive`, it must have been `pending` or `candidate`
    // - if the `state` becomes `pending`, it must have been `inactive`
    // - if the `state` becomes `candidate`, it must have been `pending` or `inactive`
  },
  _ =&gt; false,
}
</code></pre>
</li>
<li><code>validator/{validator_address}/total_deltas</code>:
<ul>
<li>find the difference between the pre-state and post-state values and add it to the <code>total_deltas</code> accumulator and update <code>total_stake_by_epoch</code>, <code>expected_voting_power_by_epoch</code> and <code>expected_total_voting_power_delta_by_epoch</code></li>
</ul>
</li>
<li><code>validator/{validator_address}/voting_power</code>:
<ul>
<li>find the difference between the pre-state and post-state value and insert it into the <code>voting_power_by_epoch</code> accumulator</li>
</ul>
</li>
<li><code>bond/{bond_source}/{bond_validator}/delta</code>:
<ul>
<li>for each difference between the post-state and pre-state values:
<ul>
<li>if the difference is not in epoch <code>n</code> or <code>n + pipeline_length</code>, panic</li>
<li>find slashes for the <code>bond_validator</code>, if any, and apply them to the delta value</li>
<li>add it to the <code>bond_delta</code> accumulator</li>
</ul>
</li>
</ul>
</li>
<li><code>unbond/{unbond_source}/{unbond_validator}/deltas</code>:
<ul>
<li>for each difference between the post-state and pre-state values:
<ul>
<li>if the difference is not in epoch <code>n</code> or <code>n + unboding_length</code>, panic</li>
<li>find slashes for the <code>bond_validator</code>, if any, and apply them to the delta value</li>
<li>add it to the <code>unbond_delta</code> accumulator</li>
</ul>
</li>
</ul>
</li>
<li><code>validator_set</code>:
<ul>
<li>set the accumulators <code>validator_set_pre</code> and <code>validator_set_post</code></li>
</ul>
</li>
<li><code>total_voting_power</code>:
<ul>
<li>find the difference between the post-state and pre-state</li>
<li>add it to the <code>total_voting_power_delta_by_epoch</code> accumulator</li>
</ul>
</li>
<li>PoS account's balance:
<ul>
<li>find the difference between the post-state and pre-state</li>
<li>add it to the <code>balance_delta</code> accumulator</li>
</ul>
</li>
</ul>
<p>No other storage key changes are permitted by the VP.</p>
<p>After the storage keys iteration, we check the accumulators:</p>
<ul>
<li>For each <code>total_deltas</code>, there must be the same delta value in <code>bond_delta</code>.</li>
<li>For each <code>bond_delta</code>, there must be validator's change in <code>total_deltas</code>.</li>
<li>Check that all positive <code>unbond_delta</code> also have a <code>total_deltas</code> update. Negative unbond delta is from withdrawing, which removes tokens from unbond, but doesn't affect total deltas.</li>
<li>Check validator sets updates against validator total stakes.</li>
<li>Check voting power changes against validator total stakes.</li>
<li>Check expected voting power changes against <code>voting_power_by_epoch</code>.</li>
<li>Check expected total voting power change against <code>total_voting_power_delta_by_epoch</code>.</li>
<li>Check that the sum of bonds and unbonds deltas is equal to the balance delta.</li>
<li>Check that all the new validators have their required fields set and that they have been added to the validator set</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="crypto-primitives"><a class="header" href="#crypto-primitives">Crypto primitives</a></h1>
<p><a href="https://github.com/anoma/anoma/issues/39">Tracking Issue</a></p>
<hr />
<p>This page should describe cryptography primitives that we might want to use, such as types of keys, hashing functions, etc.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="actors-and-incentives"><a class="header" href="#actors-and-incentives">Actors and Incentives</a></h1>
<p>Anoma consists of various actors fulfilling various roles in the network. They are all incentivized to act for the good of the network. The native Anoma token <code>XAN</code> is used to settle transaction fees and pay for the incentives in Anoma.</p>
<h2 id="fees-associated-with-a-transaction"><a class="header" href="#fees-associated-with-a-transaction">Fees associated with a transaction</a></h2>
<p>Users of Anoma can</p>
<ul>
<li>transfer private assets they hold to other users and</li>
<li>barter assets with other users.</li>
</ul>
<p>Each transaction may be associated with the following fees, paid in <code>XAN</code>:</p>
<ul>
<li><strong>Execution fees</strong> to compensate for computing, storage and memory costs, charges at 2 stages:
<ul>
<li><strong>initial fee (init_f)</strong>: charged before the transaction is settled</li>
<li><strong>post-execution fee (exe_f)</strong>: charged after the settlement</li>
</ul>
</li>
<li><strong>Exchange fee (ex_f)</strong>: a fee proportional to the value exchanged in a trade</li>
</ul>
<h2 id="actors-and-their-associated-fees-and-responsibilities"><a class="header" href="#actors-and-their-associated-fees-and-responsibilities">Actors and their associated fees and responsibilities</a></h2>
<table><thead><tr><th>Actor</th><th>Responsibilities</th><th>Incentives</th><th>Bond in escrow</th><th>May also be</th></tr></thead><tbody>
<tr><td>User</td><td>Make offers or send transactions</td><td>Features of Anoma</td><td>X</td><td>Anyone</td></tr>
<tr><td>Signer</td><td>Generate key shards</td><td>portions of init_f, exe_f</td><td>✓</td><td>Validator</td></tr>
<tr><td>Validator</td><td>Validate</td><td>portions of init_f, exe_f</td><td>✓</td><td>Signer</td></tr>
<tr><td>Submitter</td><td>Submit orders &amp; pay init_f</td><td>successful orders get init_f back plus bonus</td><td>X</td><td></td></tr>
<tr><td>Intent gossip operator</td><td>Signs and shares orders</td><td>portions of init_f, exe_f</td><td>X</td><td></td></tr>
<tr><td>Market maker</td><td>Signs and broadcast orders</td><td>the difference between the ask and bid price</td><td>X</td><td></td></tr>
<tr><td>Proposer</td><td>Proposes blocks</td><td>portions of init_f, exe_f</td><td></td><td>Validator</td></tr>
</tbody></table>
<p>Questions to explore:</p>
<ul>
<li>
<p>How do we calculate the incentives? What are the equations for each actor?</p>
</li>
<li>
<p>How do we calculate the bond/reward for the signers and validators?</p>
</li>
<li>
<p>How do we ensure certain dual/multi agencies are allowed but not others? E.g., signers can be validators but we may not want them to be proposers because they may have knowledge of which transactions are encrypted.</p>
</li>
</ul>
<h2 id="actors-and-fees-flowchart"><a class="header" href="#actors-and-fees-flowchart">Actors and fees flowchart</a></h2>
<p><img src="explore/design/summary.png?raw=true" alt="Summary" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="proof-of-stake-pos-system"><a class="header" href="#proof-of-stake-pos-system">Proof of Stake (PoS) system</a></h1>
<h2 id="epoch"><a class="header" href="#epoch">Epoch</a></h2>
<p>An epoch is a range of blocks or time that is defined by the base ledger and made available to the PoS system. This document assumes that epochs are identified by consecutive natural numbers. All the data relevant to PoS are <a href="explore/design/pos.html#epoched-data">associated with epochs</a>.</p>
<h3 id="epoched-data"><a class="header" href="#epoched-data">Epoched data</a></h3>
<p>Epoched data are data associated with a specific epoch that are set in advance. The data relevant to the PoS system in the ledger's state are epoched. Each data can be uniquely identified. These are:</p>
<ul>
<li><a href="explore/design/pos.html#system-parameters">System parameters</a>. A single value for each epoch.</li>
<li><a href="explore/design/pos.html#active-validator-set">Active validator set</a>. A single value for each epoch.</li>
<li>Total voting power. A sum of all active and inactive validators' voting power. A single value for each epoch.</li>
<li><a href="explore/design/pos.html#validator">Validators' consensus key, state and total bonded tokens</a>. Identified by the validator's address.</li>
<li><a href="explore/design/pos.html#bonds">Bonds</a> are created by self-bonding and delegations. They are identified by the pair of source address and the validator's address.</li>
</ul>
<p>Changes to the epoched data do not take effect immediately. Instead, changes in epoch <code>n</code> are queued to take effect in the epoch <code>n + pipeline_length</code> for most cases and <code>n + unboding_length</code> for <a href="explore/design/pos.html#unbond">unbonding</a> actions. Should the same validator's data or same bonds (i.e. with the same identity) be updated more than once in the same epoch, the later update overrides the previously queued-up update. For bonds, the token amounts are added up. Once the epoch <code>n</code> has ended, the queued-up updates for epoch <code>n + pipeline_length</code> are final and the values become immutable.</p>
<h2 id="entities"><a class="header" href="#entities">Entities</a></h2>
<ul>
<li><a href="explore/design/pos.html#validator">Validator</a>: An account with a public consensus key, which may participate in producing blocks and governance activities. A validator may not also be a delegator.</li>
<li><a href="explore/design/pos.html#delegator">Delegator</a>: An account that delegates some tokens to a validator. A delegator may not also be a validator.</li>
</ul>
<p>Additionally, any account may submit evidence for <a href="explore/design/pos.html#slashing">a slashable misbehaviour</a>.</p>
<h3 id="validator"><a class="header" href="#validator">Validator</a></h3>
<p>A validator must have a public consensus key. Additionally, it may also specify optional metadata fields (TBA).</p>
<p>A validator may be in one of the following states:</p>
<ul>
<li><em>inactive</em>:
A validator is not being considered for block creation and cannot receive any new delegations.</li>
<li><em>pending</em>:
A validator has requested to become a <em>candidate</em>.</li>
<li><em>candidate</em>:
A validator is considered for block creation and can receive delegations.</li>
</ul>
<p>For each validator (in any state), the system also tracks total bonded tokens as a sum of the tokens in their self-bonds and delegated bonds, less any unbonded tokens. The total bonded tokens determine their voting voting power by multiplication by the <code>votes_per_token</code> <a href="explore/design/pos.html#system-parameters">parameter</a>. The voting power is used for validator selection for block creation and is used in governance related activities.</p>
<h4 id="validator-actions"><a class="header" href="#validator-actions">Validator actions</a></h4>
<ul>
<li><em>become validator</em>:
Any account that is not a validator already and that doesn't have any delegations may request to become a validator. It is required to provide a public consensus key and staking reward address. For the action applied in epoch <code>n</code>, the validator's state will be immediately set to <em>pending</em>, it will be set to <em>candidate</em> for epoch <code>n + pipeline_length</code> and the consensus key is set for epoch <code>n + pipeline_length</code>.</li>
<li><em>deactivate</em>:
Only a <em>pending</em> or <em>candidate</em> validator account may <em>deactivate</em>. For this action applied in epoch <code>n</code>, the validator's account is set to become <em>inactive</em> in the epoch <code>n + pipeline_length</code>.</li>
<li><em>reactivate</em>:
Only an <em>inactive</em> validator may <em>reactivate</em>. Similarly to <em>become validator</em> action, for this action applied in epoch <code>n</code>, the validator's state will be immediately set to <em>pending</em> and it will be set to <em>candidate</em> for epoch <code>n + pipeline_length</code>.</li>
<li><em>self-bond</em>:
A validator may lock-up tokens into a <a href="explore/design/pos.html#bonds">bond</a> only for its own validator's address.</li>
<li><em>unbond</em>:
Any self-bonded tokens may be partially or fully <a href="explore/design/pos.html#unbond">unbonded</a>.</li>
<li><em>withdraw unbonds</em>:
Unbonded tokens may be withdrawn in or after the <a href="explore/design/pos.html#unbond">unbond's epoch</a>.</li>
<li><em>change consensus key</em>:
Set the new consensus key. When applied in epoch <code>n</code>, the key is set for epoch <code>n + pipeline_length</code>.</li>
</ul>
<h4 id="active-validator-set"><a class="header" href="#active-validator-set">Active validator set</a></h4>
<p>From all the <em>candidate</em> validators, in each epoch the ones with the most voting power limited up to the <code>max_active_validators</code> <a href="explore/design/pos.html#system-parameters">parameter</a> are selected for the active validator set. The active validator set selected in epoch <code>n</code> is set for epoch <code>n + pipeline_length</code>.</p>
<h3 id="delegator"><a class="header" href="#delegator">Delegator</a></h3>
<p>A delegator may have any number of delegations to any number of validators. Delegations are stored in <a href="explore/design/pos.html#bonds">bonds</a>.</p>
<h4 id="delegator-actions"><a class="header" href="#delegator-actions">Delegator actions</a></h4>
<ul>
<li><em>delegate</em>:
An account which is not a validator may delegate tokens to any number of validators. This will lock-up tokens into a <a href="explore/design/pos.html#bonds">bond</a>.</li>
<li><em>undelegate</em>:
Any delegated tokens may be partially or fully <a href="explore/design/pos.html#unbond">unbonded</a>.</li>
<li><em>withdraw unbonds</em>:
Unbonded tokens may be withdrawn in or after the <a href="explore/design/pos.html#unbond">unbond's epoch</a>.</li>
</ul>
<h2 id="bonds"><a class="header" href="#bonds">Bonds</a></h2>
<p>A bond locks-up tokens from validators' self-bonding and delegators' delegations. For self-bonding, the source address is equal to the validator's address. Only validators can self-bond. For a bond created from a delegation, the bond's source is the delegator's account.</p>
<p>For each epoch, bonds are uniquely identified by the pair of source and validator's addresses. A bond created in epoch <code>n</code> is written into epoch <code>n + pipeline_length</code>. If there already is a bond in the epoch <code>n + pipeline_length</code> for this pair of source and validator's addresses, its tokens are incremented by the newly bonded amount.</p>
<p>Any bonds created in epoch <code>n</code> increment the bond's validator's total bonded tokens by the bond's token amount and update the voting power for epoch <code>n + pipeline_length</code>.</p>
<p>The tokens put into a bond are immediately deducted from the source account.</p>
<h3 id="unbond"><a class="header" href="#unbond">Unbond</a></h3>
<p>An unbonding action (validator <em>unbond</em> or delegator <em>undelegate</em>) requested by the bond's source account in epoch <code>n</code> creates an &quot;unbond&quot; with epoch set to <code>n + unbounding_length</code>. We also store the epoch of the bond(s) from which the unbond is created in order to determine if the unbond should be slashed if a fault occurred within the range of bond epoch (inclusive) and unbond epoch (exclusive).</p>
<p>Any unbonds created in epoch <code>n</code> decrements the bond's validator's total bonded tokens by the bond's token amount and update the voting power for epoch <code>n + unbonding_length</code>.</p>
<p>An &quot;unbond&quot; with epoch set to <code>n</code> may be withdrawn by the bond's source address in or any time after the epoch <code>n</code>. Once withdrawn, the unbond is deleted and the tokens are credited to the source account.</p>
<h3 id="staking-rewards"><a class="header" href="#staking-rewards">Staking rewards</a></h3>
<p>To a validator who proposed a block, the system rewards tokens based on the <code>block_proposer_reward</code> <a href="explore/design/pos.html#system-parameters">system parameter</a> and each validator that voted on a block receives <code>block_vote_reward</code>.</p>
<h3 id="slashing-1"><a class="header" href="#slashing-1">Slashing</a></h3>
<p>Instead of absolute values, validators' total bonded token amounts and bonds' and unbonds' token amounts are stored as their deltas (i.e. the change of quantity from a previous epoch) to allow distinguishing changes for different epoch, which is essential for determining whether tokens should be slashed. However, because slashes for a fault that occurred in epoch <code>n</code> may only be applied before the beginning of epoch <code>n + unbonding_length</code>, in epoch <code>m</code> we can sum all the deltas of total bonded token amounts and bonds and unbond with the same source and validator for epoch equal or less than <code>m - unboding_length</code> into a single total bonded token amount, single bond and single unbond record. This is to keep the total number of total bonded token amounts for a unique validator and bonds and unbonds for a unique pair of source and validator bound to a maximum number (equal to <code>unbonding_length</code>).</p>
<p>To disincentivize validators misbehaviour in the PoS system a validator may be slashed for any fault that it has done. An evidence of misbehaviour may be submitted by any account for a fault that occurred in epoch <code>n</code> anytime before the beginning of epoch <code>n + unbonding_length</code>.</p>
<p>A valid evidence reduces the validator's total bonded token amount by the slash rate in and before the epoch in which the fault occurred. The validator's voting power must also be adjusted to the slashed total bonded token amount. Additionally, a slash is stored with the misbehaving validator's address and the relevant epoch in which the fault occurred. When an unbond is being withdrawn, we first look-up if any slash occurred within the range of epochs in which these were active and if so, reduce its token amount by the slash rate. Note that bonds and unbonds amounts are not slashed until their tokens are withdrawn.</p>
<p>The invariant is that the sum of amounts that may be withdrawn from a misbehaving validator must always add up to the total bonded token amount.</p>
<h2 id="system-parameters"><a class="header" href="#system-parameters">System parameters</a></h2>
<p>The default values that are relative to epoch duration assume that an epoch last about 24 hours.</p>
<ul>
<li><code>max_validator_slots</code>: Maximum active validators, default <code>128</code></li>
<li><code>pipeline_len</code>: Pipeline length in number of epochs, default <code>2</code></li>
<li><code>unboding_len</code>: Unbonding duration in number of epochs, default <code>6</code></li>
<li><code>votes_per_token</code>: Used in validators' voting power calculation, default 100‱ (1 voting power unit per 1000 tokens)</li>
<li><code>block_proposer_reward</code>: Amount of tokens rewarded to a validator for proposing a block</li>
<li><code>block_vote_reward</code>: Amount of tokens rewarded to each validator that voted on a block proposal</li>
<li><code>duplicate_vote_slash_rate</code>: Portion of validator's stake that should be slashed on a duplicate vote</li>
<li><code>light_client_attack_slash_rate</code>: Portion of validator's stake that should be slashed on a light client attack</li>
</ul>
<h2 id="storage-1"><a class="header" href="#storage-1">Storage</a></h2>
<p>The <a href="explore/design/pos.html#system-parameters">system parameters</a> are written into the storage to allow for their changes. Additionally, each validator may record a new parameters value under their sub-key that they wish to change to, which would override the systems parameters when more than 2/3 voting power are in agreement on all the parameters values.</p>
<p>The validators' data are keyed by the their addresses, conceptually:</p>
<pre><code class="language-rust ignore">type Validators = HashMap&lt;Address, Validator&gt;;
</code></pre>
<p>Epoched data are stored in the following structure:</p>
<pre><code class="language-rust ignore">struct Epoched&lt;Data&gt; {
  /// The epoch in which this data was last updated
  last_update: Epoch,
  /// Dynamically sized vector in which the head is the data for epoch in which 
  /// the `last_update` was performed and every consecutive array element is the
  /// successor epoch of the predecessor array element. For system parameters, 
  /// validator's consensus key and state, `LENGTH = pipeline_length + 1`. 
  /// For all others, `LENGTH = unbonding_length + 1`.
  data: Vec&lt;Option&lt;Data&gt;&gt;
}
</code></pre>
<p>Note that not all epochs will have data set, only the ones in which some changes occurred.</p>
<p>To try to look-up a value for <code>Epoched</code> data with independent values in each epoch (such as the active validator set) in the current epoch <code>n</code>:</p>
<ol>
<li>let <code>index = min(n - last_update, pipeline_length)</code></li>
<li>read the <code>data</code> field at <code>index</code>:
<ol>
<li>if there's a value at <code>index</code> return it</li>
<li>else if <code>index == 0</code>, return <code>None</code></li>
<li>else decrement <code>index</code> and repeat this sub-step from 1.</li>
</ol>
</li>
</ol>
<p>To look-up a value for <code>Epoched</code> data with delta values in the current epoch <code>n</code>:</p>
<ol>
<li>let <code>end = min(n - last_update, pipeline_length) + 1</code></li>
<li>sum all the values that are not <code>None</code> in the <code>0 .. end</code> range bounded inclusively below and exclusively above</li>
</ol>
<p>To update a value in <code>Epoched</code> data with independent values in epoch <code>n</code> with value <code>new</code> for epoch <code>m</code>:</p>
<ol>
<li>let <code>shift = min(n - last_update, pipeline_length)</code></li>
<li>if <code>shift == 0</code>:
<ol>
<li><code>data[m - n] = new</code></li>
</ol>
</li>
<li>else:
<ol>
<li>for <code>i in 0 .. shift</code> range bounded inclusively below and exclusively above, set <code>data[i] = None</code></li>
<li>rotate <code>data</code> left by <code>shift</code></li>
<li>set <code>data[m - n] = new</code></li>
<li>set <code>last_update</code> to the current epoch</li>
</ol>
</li>
</ol>
<p>To update a value in <code>Epoched</code> data with delta values in epoch <code>n</code> with value <code>delta</code> for epoch <code>m</code>:</p>
<ol>
<li>let <code>shift = min(n - last_update, pipeline_length)</code></li>
<li>if <code>shift == 0</code>:
<ol>
<li>set <code>data[m - n] = data[m - n].map_or_else(delta, |last_delta| last_delta + delta)</code> (add the <code>delta</code> to the previous value, if any, otherwise use the <code>delta</code> as the value)</li>
</ol>
</li>
<li>else:
<ol>
<li>let <code>sum</code> to be equal to the sum of all delta values in the <code>i in 0 .. shift</code> range bounded inclusively below and exclusively above and set <code>data[i] = None</code></li>
<li>rotate <code>data</code> left by <code>shift</code></li>
<li>set <code>data[0] = data[0].map_or_else(sum, |last_delta| last_delta + sum)</code></li>
<li>set <code>data[m - n] = delta</code></li>
<li>set <code>last_update</code> to the current epoch</li>
</ol>
</li>
</ol>
<p>The invariants for updates in both cases are that <code>m - n &gt;= 0</code> and <code>m - n &lt;= pipeline_length</code>.</p>
<p>For the active validator set, we store all the active and inactive validators separately with their respective voting power:</p>
<pre><code class="language-rust ignore">type VotingPower = u64;

/// Validator's address with its voting power.
#[derive(PartialEq, Eq, PartialOrd, Ord)]
struct WeightedValidator {
  /// The `voting_power` field must be on top, because lexicographic ordering is
  /// based on the top-to-bottom declaration order and in the `ValidatorSet`
  /// the `WeighedValidator`s these need to be sorted by the `voting_power`.
  voting_power: VotingPower,
  address: Address,
}

struct ValidatorSet {
  /// Active validator set with maximum size equal to `max_active_validators`
  active: BTreeSet&lt;WeightedValidator&gt;,
  /// All the other validators that are not active
  inactive: BTreeSet&lt;WeightedValidator&gt;,
}

type ValidatorSets = Epoched&lt;ValidatorSet&gt;;

/// The sum of all active and inactive validators' voting power
type TotalVotingPower = Epoched&lt;VotingPower&gt;;
</code></pre>
<p>When any validator's voting power changes, we attempt to perform the following update on the <code>ActiveValidatorSet</code>:</p>
<ol>
<li>let <code>validator</code> be the validator's address, <code>power_before</code> and <code>power_after</code> be the voting power before and after the change, respectively</li>
<li>let <code>power_delta = power_after - power_before</code></li>
<li>let <code>min_active = active.first()</code> (active validator with lowest voting power)</li>
<li>let <code>max_inactive = inactive.last()</code> (inactive validator with greatest voting power)</li>
<li>find whether the validator is active, let <code>is_active = power_before &gt;= max_inactive.voting_power</code>
<ol>
<li>if <code>is_active</code>:
<ol>
<li>if <code>power_delta &gt; 0 &amp;&amp; power_after &gt; max_inactive.voting_power</code>, update the validator in <code>active</code> set with <code>voting_power = power_after</code></li>
<li>else, remove the validator from <code>active</code>, insert it into <code>inactive</code> and remove <code>max_inactive.address</code> from <code>inactive</code> and insert it into <code>active</code></li>
</ol>
</li>
<li>else (<code>!is_active</code>):
<ol>
<li>if <code>power_delta &lt; 0 &amp;&amp; power_after &lt; min_active.voting_power</code>, update the validator in <code>inactive</code> set with <code>voting_power = power_after</code></li>
<li>else, remove the validator from <code>inactive</code>, insert it into <code>active</code> and remove <code>min_active.address</code> from <code>active</code> and insert it into <code>inactive</code></li>
</ol>
</li>
</ol>
</li>
</ol>
<p>Within each validator's address space, we store public consensus key, state, total bonded token amount and voting power calculated from the total bonded token amount (even though the voting power is stored in the <code>ValidatorSet</code>, we also need to have the <code>voting_power</code> here because we cannot look it up in the <code>ValidatorSet</code> without iterating the whole set):</p>
<pre><code class="language-rust ignore">struct Validator {
  consensus_key: Epoched&lt;PublicKey&gt;,
  state: Epoched&lt;ValidatorState&gt;,
  total_deltas: Epoched&lt;token::Amount&gt;,
  voting_power: Epoched&lt;VotingPower&gt;,
}

enum ValidatorState {
  Inactive,
  Pending,
  Candidate,
}
</code></pre>
<p>The bonds and unbonds are keyed by their identifier:</p>
<pre><code class="language-rust ignore">type Bonds = HashMap&lt;BondId, Epoched&lt;Bond&gt;&gt;;
type Unbonds = HashMap&lt;BondId, Epoched&lt;Unbond&gt;&gt;;

struct BondId {
  validator: Address,
  /// The delegator adddress for delegations, or the same as the `validator`
  /// address for self-bonds.
  source: Address,
}

struct Bond {
  /// A key is a the epoch set for the bond. This is used in unbonding, where
  // it's needed for slash epoch range check.
  deltas: HashMap&lt;Epoch, token::Amount&gt;,
}

struct Unbond {
  /// A key is a pair of the epoch of the bond from which a unbond was created
  /// the epoch of unboding. This is needed for slash epoch range check.
  deltas: HashMap&lt;(Epoch, Epoch), token::Amount&gt;
}
</code></pre>
<p>For slashes, we store the epoch and block height at which the fault occurred, slash rate and the slash type:</p>
<pre><code class="language-rust ignore">struct Slash {
  epoch: Epoch,
  block_height: u64,
  /// slash token amount ‱ (per ten thousand)
  rate: u8,
  r#type: SlashType,
}
</code></pre>
<h2 id="initialization-1"><a class="header" href="#initialization-1">Initialization</a></h2>
<p>An initial validator set with self-bonded token amounts must be given on system initialization.</p>
<p>This set is used to pre-compute epochs in the genesis block from epoch <code>0</code> to epoch <code>pipeline_length - 1</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testnet-setup"><a class="header" href="#testnet-setup">Testnet setup</a></h1>
<p>Starting from a release branch, we configure the network that will run on this release.</p>
<h2 id="step-1-prepare-a-genesis-configuration-file"><a class="header" href="#step-1-prepare-a-genesis-configuration-file">Step 1: Prepare a genesis configuration file</a></h2>
<p>Prepare a genesis configuration file. You can start from one of the source files in the <a href="https://github.com/heliaxdev/anoma-network-config/tree/master/src">anoma-network-config repo</a> or the source files inside the <code>genesis</code> directory in this repository, or start from scratch. Note that in this file, for any account for which you don't specify address and/or keys, they will be automatically generated in the next step and saved in wallet(s) in the network &quot;setup&quot; directory.</p>
<p>Additionally, for validator accounts you should also specify their <code>net_address</code>. Note that for each validator node we're using up to 5 ports (3 for the ledger and 2 for the intent gossip), so if multiple validators are running behind the same public IP, their ports should be increments of 5 (e.g. <code>26656</code>, <code>26661</code>, ...). A port supplied in the <code>net_address</code> will be used for the node's P2P address. The ledger's RPC address address is its <code>{port + 1}</code> and the Anoma ledger's port is <code>{port + 2}</code>. The intent gossip will run on <code>{port + 3}</code> and its RPC server at <code>{post + 4}</code>.</p>
<p>In the genesis file, also set the <code>genesis_time</code> in <a href="https://www.ietf.org/rfc/rfc3339.txt">RFC3339</a> format, e.g. <code>2021-09-30T10:00:00Z</code>. It's the time the blockchain started or will start. If nodes are started before this time they will sit idle until the time specified.</p>
<h2 id="step-2-initialize-new-network-using-the-utils-command"><a class="header" href="#step-2-initialize-new-network-using-the-utils-command">Step 2: Initialize new network using the utils command</a></h2>
<ul>
<li>Choose a <code>chain_prefix</code> for a new chain ID (e.g. <code>anoma-feigenbaum-0</code>). Allows up to 19 alphanumeric characters and <code>.</code>, <code>-</code> and <code>_</code>.</li>
<li>Run <code>anomac utils init-network --genesis-path genesis/{file_from_last_step}.toml --chain-prefix {chain_prefix}</code> to (note that you can also specify other options, for example <code>--localhost</code> to setup a local network, <code>--allow-duplicate-ip</code> to allow multiple ledger nodes to run under the same IP address, which is useful for testnets):
<ul>
<li>Generate a new <code>chain_id</code> with the chosen <code>chain_prefix</code> (up to 19 chars), a separator char <code>.</code> and the hash of the genesis data, 30 characters long in total (<code>shared/src/types/chain.rs</code>)</li>
<li>For each validator (index <code>n</code>), prepare the base directory under <code>{base_dir}/{chain_prefix}/setup/validator_{n}</code> with:
<ul>
<li>A wallet with the validator's addresses and keys</li>
<li>Tendermint config with its private validator key (consensus key) and node key (from which its node ID is derived)</li>
<li>Tendermint data private validator state file (this is required by Tendermint)</li>
<li>Add global config, chain config and genesis file</li>
<li>Set ledger's config <code>p2p_pex</code> to <code>false</code></li>
<li>Update chain config ledger's address, P2P and RPC address and intent gossip's config P2P and RPC address.</li>
</ul>
</li>
<li>Write genesis config file, and ledger and intent gossip configs</li>
<li>Save the genesis file to the <code>{base_dir}/{chain_id}.toml</code> and print the full path</li>
<li>Generate a global config in <code>{base_dir}/global-config.toml</code> with the {chain_id}</li>
<li>Print the chain ID and the path to the network's genesis file</li>
<li>Create a public release archive file with the genesis file and global and chain config files and print its name (<code>{chain_id}.tar.gz</code>)</li>
</ul>
</li>
<li>Verify that the configs are valid and can be parsed by running <code>cargo run --package anoma_apps --no-default-features --features std --bin anoman ledger</code> (TODO add a sub-cmd to verify the genesis config before its finalized - at the end of step 1)</li>
</ul>
<h2 id="step-3-deploy"><a class="header" href="#step-3-deploy">Step 3: Deploy</a></h2>
<ul>
<li>Upload the validator directories to host(s)
<ul>
<li>each validator's wallet and config is prepared under <code>{base_dir}/{chain_id}/setup/{validator_alias}</code></li>
</ul>
</li>
<li>Distribute:
<ul>
<li><code>{base_dir}/global-config.toml</code></li>
<li><code>{base_dir}/{chain_id}/config.toml</code></li>
<li><code>{base_dir}/{chain_id}/genesis.toml</code></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testnet-launch-procedure"><a class="header" href="#testnet-launch-procedure">Testnet Launch Procedure</a></h1>
<h2 id="desiderata"><a class="header" href="#desiderata">Desiderata</a></h2>
<ul>
<li>Simple process for deploying new software versions to testnets</li>
<li>Avoid debugging software on testnets (operationally expensive)</li>
<li>Integrated <em>as much as possible</em> into a regular engineering workflow</li>
<li>Coordinating deployment with testnet operators
<ul>
<li>Clear communication of latest version &amp; how to operate</li>
</ul>
</li>
<li>Written process (preflight checklist) to minimise chances of error</li>
</ul>
<h2 id="flavours-of-testnets"><a class="header" href="#flavours-of-testnets">Flavours of testnets</a></h2>
<ul>
<li>Internal testnet (Heliax-only)
<ul>
<li>e.g. namada-internal-testnet-1</li>
</ul>
</li>
<li>Private (close-quarters) testnet (invite-only)
<ul>
<li>Private invite-only channel on Discord</li>
<li>Select group of participants (validators)</li>
</ul>
</li>
<li>Public testnet
<ul>
<li>Anyone can join, everything is public</li>
<li>Still coordinated on Discord</li>
</ul>
</li>
</ul>
<h2 id="current-process"><a class="header" href="#current-process">Current process</a></h2>
<ol>
<li>Ray runs <code>anoma-network-init</code> through interactive prompts, get to a started network on cloud infrastructure, config files on Github.
<ul>
<li>Ask anyone else for help if necessary.</li>
</ul>
</li>
<li>Alex R. updates, reads through, QA checks the testnet documentation for this version.
<ul>
<li>Ask anyone else for docs help if necessary.</li>
</ul>
</li>
<li>Two-person signoff: Ray and Alex R. (necessary &amp; sufficient)</li>
<li>Announce that the testnet is operational, provide the link to the latest documentation page.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prototypes"><a class="header" href="#prototypes">Prototypes</a></h1>
<p>A prototype should start with a description of its goals. These can include, but are not limited to a proof of concept of novel ideas or alternative approaches, comparing different libraries and gathering feedback.</p>
<p>To get started on a prototype, please:</p>
<ul>
<li>open an issue on this repository</li>
<li>add a sub-page to this section with a link to the issue</li>
</ul>
<p>The page outlines the goals and possibly contains any notes that are not suitable to be added to the prototype source itself, while the issue should track the sub-task, their progress, and assignees.</p>
<p>The code quality is of lesser importance in prototypes. To put the main focus on the prototype's goals, we don't need to worry much about testing, linting and doc strings.</p>
<h2 id="advancing-a-successful-prototype"><a class="header" href="#advancing-a-successful-prototype">Advancing a successful prototype</a></h2>
<p>Once the goals of the prototype have been completed, we can assess if we'd like to advance the prototype to a development version. </p>
<p>In order to advance a prototype, in general we'll want to:</p>
<ul>
<li>review &amp; clean-up the code for lint, format and best practices</li>
<li>enable common Rust lints</li>
<li>review any new dependencies</li>
<li>add docs for any public interface (internally public too)</li>
<li>add automated tests</li>
<li>if the prototype has diverged from the original design, update these pages </li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="base-ledger-prototype"><a class="header" href="#base-ledger-prototype">Base ledger prototype</a></h1>
<h2 id="version-3"><a class="header" href="#version-3">Version 3</a></h2>
<p>tracking issue <a href="https://github.com/anoma/anoma/issues/125">https://github.com/anoma/anoma/issues/125</a></p>
<h3 id="goals"><a class="header" href="#goals">Goals</a></h3>
<ul>
<li>various shell and protocol fixes, improvements and additions</li>
<li>add more crypto support</li>
<li>WASM improvements</li>
<li>implement new validity predicates</li>
<li>storage improvements</li>
<li>gas &amp; fees</li>
<li>fixes for issues found in the Feigenbaum testnet</li>
<li>IBC integration</li>
<li>Ferveo/ABCI++ integration</li>
<li>PoS improvements and new features
<ul>
<li>testing (unit + integration + e2e)</li>
<li>storage values refactoring</li>
<li>use checked arithmetics</li>
<li>validator VP</li>
<li>staking rewards</li>
<li>staking reward VP</li>
<li>re-delegation</li>
<li>validator
<ul>
<li>deactivation/reactivation</li>
<li>change consensus key</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="version-2"><a class="header" href="#version-2">Version 2</a></h2>
<p>tracking issue <a href="https://github.com/anoma/anoma/issues/62">https://github.com/anoma/anoma/issues/62</a></p>
<h3 id="goals-1"><a class="header" href="#goals-1">Goals</a></h3>
<ul>
<li>storage
<ul>
<li>build key schema for access</li>
<li>implement dynamic account sub-spaces</li>
</ul>
</li>
<li>implement more complete support for WASM transactions and validity predicates
<ul>
<li>transactions can read/write all storage</li>
<li>validity predicates receive the set of changes (changed keys or complete write log) and can read their pre/post state</li>
</ul>
</li>
<li>add basic transaction gas metering</li>
<li>various other improvements</li>
</ul>
<h2 id="version-1"><a class="header" href="#version-1">Version 1</a></h2>
<p>tracking issue <a href="https://github.com/heliaxdev/rd-pm/issues/5">https://github.com/heliaxdev/rd-pm/issues/5</a></p>
<h3 id="goals-2"><a class="header" href="#goals-2">Goals</a></h3>
<ul>
<li>get some hands-on experience with Rust and Tendermint</li>
<li>initial usable node + client (+ validator?) setup</li>
<li>provide a base layer for other prototypes that need to build on top of a ledger</li>
</ul>
<h3 id="components"><a class="header" href="#components">Components</a></h3>
<p>The main components are built in a single Cargo project with <a href="explore/prototypes/base-ledger.html#shared">shared library code</a> and multiple binaries:</p>
<ul>
<li><code>anoma</code> - main executable with commands for both the node and the client (<code>anoma node</code> and <code>anoma client</code>)</li>
<li><code>anoman</code> - the <a href="explore/prototypes/base-ledger.html#node">node</a></li>
<li><code>anomac</code> - the <a href="explore/prototypes/base-ledger.html#client">client</a></li>
</ul>
<h4 id="node"><a class="header" href="#node">Node</a></h4>
<p>The node is built into <code>anoman</code>.</p>
<h5 id="shell"><a class="header" href="#shell">Shell</a></h5>
<p>The shell is what currently pulls together all the other components in the node.</p>
<p>When it's ran:</p>
<ul>
<li>establish a channel (e.g.<code>mpsc::channel</code> - Multi-producer, single-consumer FIFO queue) for communication from tendermint to the shell</li>
<li>launch tendermint node in another thread with the channel sender
<ul>
<li>send tendermint ABCI requests via the channel together with a new channel sender to receive a response</li>
</ul>
</li>
<li>run shell loop with the channel receiver, which handles ABIC requests:
<ul>
<li><a href="explore/prototypes/../design/ledger/tx.html">transaction execution</a> which includes <a href="explore/prototypes/../design/ledger/wasm-vm.html">wasm VM calls</a></li>
</ul>
</li>
</ul>
<h6 id="tendermint"><a class="header" href="#tendermint">Tendermint</a></h6>
<p>This module handles initializing and running <code>tendermint</code> and forwards messages for the ABCI requests via its channel sender.</p>
<h5 id="storage-2"><a class="header" href="#storage-2">Storage</a></h5>
<p>Key-value storage. More details are specified on <a href="explore/prototypes/../design/ledger/storage.html">Storage page</a>.</p>
<h5 id="cli"><a class="header" href="#cli">CLI</a></h5>
<ul>
<li><code>anoma run</code> to start the node (will initialize (if needed) and launch tendermint under the hood)</li>
<li><code>anoma reset</code> to delete all the node's state from DB and tendermint's state</li>
</ul>
<h4 id="client"><a class="header" href="#client">Client</a></h4>
<p>Allows to submit a transaction with an attached wasm code to the node with:</p>
<p><code>anoma tx --code tx.wasm</code></p>
<p>It presents back the received response on stdout. Currently, it waits for both the mempool validation and application in a block.</p>
<h4 id="shared"><a class="header" href="#shared">Shared</a></h4>
<h5 id="config"><a class="header" href="#config">Config</a></h5>
<p>Configuration settings:</p>
<ul>
<li>home directory (db storage and tendermint config and data)</li>
</ul>
<h5 id="genesis"><a class="header" href="#genesis">Genesis</a></h5>
<p>The genesis parameters, such as the initial validator set, are used to initialize a chain's genesis block.</p>
<h5 id="rpc-types"><a class="header" href="#rpc-types">RPC types</a></h5>
<p>The types for data that can be submitted to the node via the client's RPC commands.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="intent-gossip-system-prototype"><a class="header" href="#intent-gossip-system-prototype">Intent Gossip system prototype</a></h1>
<h2 id="version-2-1"><a class="header" href="#version-2-1">Version 2</a></h2>
<p>tracking issue <a href="https://github.com/anoma/anoma/issues/620">https://github.com/anoma/anoma/issues/620</a></p>
<ul>
<li>Separate matchmakers from intent gossiper nodes</li>
<li>Various fixes and improvements</li>
<li>fixes for issues found in the Feigenbaum testnet</li>
<li>Persistent storage</li>
<li>Intent gossip and matching of complex txs</li>
<li>multi-party trades (e.g. 10)</li>
<li>multi-asset trades (FT, NFT)</li>
<li>NFT swaps</li>
<li>Benchmarking base load for the entire network</li>
<li>Incentives</li>
<li>Docs</li>
</ul>
<h2 id="version-1-1"><a class="header" href="#version-1-1">Version 1</a></h2>
<p>tracking issue <a href="https://github.com/anoma/anoma/issues/35">https://github.com/anoma/anoma/issues/35</a></p>
<h3 id="goals-3"><a class="header" href="#goals-3">Goals</a></h3>
<ul>
<li>learning rust</li>
<li>usable node + client setup :
<ul>
<li>intent</li>
<li>incentive function</li>
<li>mempool and white list</li>
</ul>
</li>
<li>basic matchmaker</li>
</ul>
<h3 id="components-1"><a class="header" href="#components-1">components</a></h3>
<p>The intent gossip is build conjointly to the ledger and share the same binary.</p>
<h4 id="node-1"><a class="header" href="#node-1">Node</a></h4>
<p>The node is built into <code>anoman</code>, it runs all the necesarry part, rpc server,
libp2p, intent gossip app.</p>
<h5 id="intent-gossip-application"><a class="header" href="#intent-gossip-application">Intent gossip application</a></h5>
<p>The intent gossip application</p>
<h6 id="mempool"><a class="header" href="#mempool">Mempool</a></h6>
<h6 id="filter"><a class="header" href="#filter">Filter</a></h6>
<h5 id="network-behaviour"><a class="header" href="#network-behaviour">Network behaviour</a></h5>
<p>The network behaviour is the part that react on network event. It creates a
channel (e.g. <code>tokio::mpsc::channel</code>) with the intent gossip to communicate all
intent it receive.</p>
<h5 id="rpc-server"><a class="header" href="#rpc-server">Rpc server</a></h5>
<p>If the rpc command line option is set it creates a tonic server that receive
command from a client and send theses through a channel
(e.g. <code>tokio::mpsc::channel</code>) to the the intent gossip.</p>
<h4 id="client-1"><a class="header" href="#client-1">Client</a></h4>
<p>Allow to submit a intent :
<code>anoma gossip --data &quot;data&quot;</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="libraries--tools"><a class="header" href="#libraries--tools">Libraries &amp; Tools</a></h1>
<p>The aim of this section is to document possible choices for certain components. For components where many choices are available, such as a database backend, an overview of the important differences of the considered libraries may be given.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="network"><a class="header" href="#network">network</a></h1>
<h2 id="libp2p--peer-to-peer-network"><a class="header" href="#libp2p--peer-to-peer-network">Libp2p : Peer To Peer network</a></h2>
<p><a href="https://github.com/libp2p/rust-libp2p">https://github.com/libp2p/rust-libp2p</a></p>
<p>peer-to-peer framework that takes care of the transport/identity and message
encryption for us.</p>
<h2 id="tonic--clientserver-with-protobuf-prost"><a class="header" href="#tonic--clientserver-with-protobuf-prost">tonic : Client/Server with protobuf (prost)</a></h2>
<p><a href="https://github.com/hyperium/tonic">https://github.com/hyperium/tonic</a></p>
<p>Generates a client/server from protobuf file. This can be used for a rpc server.</p>
<h1 id="network-behaviour-1"><a class="header" href="#network-behaviour-1">network behaviour</a></h1>
<h2 id="gossipsub"><a class="header" href="#gossipsub">Gossipsub</a></h2>
<p><a href="https://github.com/libp2p/specs/tree/master/pubsub/gossipsub">https://github.com/libp2p/specs/tree/master/pubsub/gossipsub</a></p>
<p>Publish/Subscribe protocol, improvement over floodsub.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="command-line-interface"><a class="header" href="#command-line-interface">Command-line interface</a></h1>
<p>Important factors:</p>
<ul>
<li>UX</li>
<li>ease of use</li>
<li>cross-platform</li>
</ul>
<p>The considered libraries:</p>
<ul>
<li>clap</li>
</ul>
<h2 id="clap"><a class="header" href="#clap">Clap</a></h2>
<p><a href="https://github.com/clap-rs/clap">https://github.com/clap-rs/clap</a></p>
<p>Probably the most widely used CLI library in Rust.</p>
<p>With version 2.x, we'd probably want to use it with <a href="https://github.com/TeXitoi/structopt">Structops</a> for deriving.</p>
<p>But we can probably use 3.0, which is not yet stable, but is pretty close <a href="https://github.com/clap-rs/clap/issues/1037">https://github.com/clap-rs/clap/issues/1037</a>. This version comes with deriving attributes and also other new ways to build CLI commands.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="database"><a class="header" href="#database">Database</a></h1>
<p>Important factors:</p>
<ul>
<li>persistent key/value storage</li>
<li>reliability and efficiency (runtime performance and disk usage)</li>
<li>thread safety</li>
<li>ease of use</li>
</ul>
<p>The considered DBs:</p>
<ul>
<li>LMDB</li>
<li>LevelDB</li>
<li>RocksDB</li>
<li>sled - Rust native</li>
</ul>
<p>To watch:</p>
<ul>
<li><a href="https://docs.rs/sanakirja">sanakirja</a> - too new to be considered for now, but has some <a href="https://pijul.org/posts/2021-02-06-rethinking-sanakirja/">promising initial results</a> - TLDR. it can <em>fork tables</em> efficiently, it beats LMDB in benchmarks and usability</li>
</ul>
<p>The current preference is for RocksDB as it's tried and tested. Eventually, we might want to benchmark against other backends for our specific use case.</p>
<h2 id="lmdb"><a class="header" href="#lmdb">LMDB</a></h2>
<p><a href="https://symas.com/lmdb/">https://symas.com/lmdb/</a></p>
<p>A compact and efficient, persistent in-memory (i.e. mmap-based) B+trees database. Reportedly has a great read performance, but not as good at writing.</p>
<p>Rust bindings:</p>
<ul>
<li><a href="https://github.com/mozilla/rkv">https://github.com/mozilla/rkv</a></li>
<li><a href="https://github.com/AltSysrq/lmdb-zero">https://github.com/AltSysrq/lmdb-zero</a></li>
<li><a href="https://github.com/vhbit/lmdb-rs">https://github.com/vhbit/lmdb-rs</a> - some <a href="https://github.com/vhbit/lmdb-rs/issues/32#issuecomment-310906601">comparison notes</a> with danburkert/lmdb-rs</li>
<li><a href="https://github.com/danburkert/lmdb-rs">https://github.com/danburkert/lmdb-rs</a></li>
</ul>
<h2 id="leveldb"><a class="header" href="#leveldb">LevelDB</a></h2>
<p>Log Structured Merge Tree db. Uses one global lock. Better write performance than LMDB and lower DB size.</p>
<p>Rust bindings:</p>
<ul>
<li><a href="https://github.com/skade/leveldb">https://github.com/skade/leveldb</a></li>
</ul>
<h2 id="rocksdb-1"><a class="header" href="#rocksdb-1">RocksDB</a></h2>
<p>A fork of LevelDB with different optimizations (supposedly for RAM and flash storage).</p>
<p>Used in <a href="https://github.com/simplestaking/tezedge">https://github.com/simplestaking/tezedge</a> and <a href="https://github.com/near/nearcore">https://github.com/near/nearcore</a>.</p>
<p>Rust bindings:</p>
<ul>
<li><a href="https://github.com/rust-rocksdb/rust-rocksdb">https://github.com/rust-rocksdb/rust-rocksdb</a></li>
</ul>
<h2 id="sled"><a class="header" href="#sled">Sled</a></h2>
<p>Repo: <a href="https://github.com/spacejam/sled">https://github.com/spacejam/sled</a>
Homepage: <a href="https://sled.rs/">https://sled.rs/</a></p>
<p>Modern, zero-copy reads, lock-free and many more features.</p>
<hr />
<h1 id="merkle-tree-data-structure"><a class="header" href="#merkle-tree-data-structure">Merkle tree data structure</a></h1>
<p>Some popular choices for merkle tree in the industry are AVL(+) tree, Patricia Trie and Sparse Merkle Tree, each with different trade-offs.</p>
<p>AVL(+) tree is used in e.g. <a href="https://github.com/cosmos/iavl">Cosmos</a>. The advantage of this structure is that key don't need to be hashed prior to insertion/look-up.</p>
<p>Patricia trie used in e.g. <a href="https://eth.wiki/en/fundamentals/patricia-tree">Ethereum</a> and <a href="https://www.dailambda.jp/blog/2020-05-11-plebeia/">Plebeia for Tezos</a> are designed to be more space efficient.</p>
<p>Sparse Merle tree as described in <a href="https://ethresear.ch/t/optimizing-sparse-merkle-trees/3751">Optimizing sparse Merkle trees</a> used in e.g. <a href="https://ethresear.ch/t/plasma-cash-with-sparse-merkle-trees-bloom-filters-and-probabilistic-transfers/2006">Plasma Cash</a> are somewhat similar to Patricia trees, but perhaps conceptually simpler.</p>
<ul>
<li>Compact Sparse Merkle Trees <a href="https://eprint.iacr.org/2018/955.pdf">https://eprint.iacr.org/2018/955.pdf</a></li>
<li>Efficient Sparse Merkle Trees (caching) <a href="https://eprint.iacr.org/2016/683.pdf">https://eprint.iacr.org/2016/683.pdf</a></li>
</ul>
<p>Considered libraries:</p>
<ul>
<li>merk</li>
<li>sparse-merkle-tree</li>
<li>patricia_tree</li>
</ul>
<h2 id="merk"><a class="header" href="#merk">merk</a></h2>
<p><a href="https://github.com/nomic-io/merk">https://github.com/nomic-io/merk</a></p>
<p>Using AVL tree built on top of RocksDB. It makes it easy to setup Merkle tree storage, but:</p>
<ul>
<li>is not yet fully implemented as described (e.g. <a href="https://github.com/nomic-io/merk/issues/26">concurrent ops</a>)</li>
<li>benchmarks seem to differ from results in README</li>
<li>doesn't have past states of the tree, instead <a href="https://github.com/nomic-io/merk/blob/develop/docs/algorithms.md#database-representation">relies on RocksDB snapshot/checkpoint features</a>, which means that it's <a href="https://github.com/nomic-io/merk/issues/11">strongly coupled</a></li>
<li>uses a custom <a href="https://github.com/nomic-io/ed">encoding lib</a> which is zero-copy, but big-endian everywhere</li>
<li>there are a <code>unsafe</code> usages that are not well described/justified</li>
<li>uses some experimental dep such as <a href="https://github.com/rust-lang-nursery/failure">https://github.com/rust-lang-nursery/failure</a> (now deprecated)</li>
</ul>
<h2 id="sparse-merkle-tree"><a class="header" href="#sparse-merkle-tree">sparse-merkle-tree</a></h2>
<p><a href="https://github.com/jjyr/sparse-merkle-tree">https://github.com/jjyr/sparse-merkle-tree</a></p>
<p>A nice abstraction, albeit not yet declared stable. It allows to plug-in a custom hasher function (which is important for <a href="https://github.com/heliaxdev/rd-pm/issues/11">circuit friendliness</a>) and storage backend. Has minimal dependencies and support Rust <code>no_std</code>.</p>
<h2 id="patricia_tree"><a class="header" href="#patricia_tree">patricia_tree</a></h2>
<p><a href="https://github.com/sile/patricia_tree">https://github.com/sile/patricia_tree</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="logging"><a class="header" href="#logging">Logging</a></h1>
<p>Options to consider:</p>
<ul>
<li>env_logger</li>
<li>slog</li>
<li>tracing</li>
</ul>
<p>The current preference is for tracing in combination with tracing-subscriber (to log collected events and traces), because we have some async and parallelized code. In future, we should also add tracing-appender for rolling file logging.</p>
<h2 id="env_logger"><a class="header" href="#env_logger">Env_logger</a></h2>
<p><a href="https://github.com/env-logger-rs/env_logger/">https://github.com/env-logger-rs/env_logger/</a></p>
<p>A simple logger used by many Rust tools, configurable by env vars. Usually combined with <a href="https://github.com/seanmonstar/pretty-env-logger">pretty-env-logger</a>.</p>
<h2 id="slog"><a class="header" href="#slog">Slog</a></h2>
<p><a href="https://github.com/slog-rs/slog">https://github.com/slog-rs/slog</a></p>
<p>Composable, structured logger. Many extra libraries with extra functionality, e.g.:</p>
<ul>
<li><a href="https://github.com/slog-rs/envlogger">https://github.com/slog-rs/envlogger</a> port of env_logger as a slog-rs drain </li>
</ul>
<h2 id="tracing"><a class="header" href="#tracing">Tracing</a></h2>
<p><a href="https://github.com/tokio-rs/tracing">https://github.com/tokio-rs/tracing</a></p>
<p>Tracing &amp; logging better suited for concurrent processes and async code. Many extra libraries with extra functionality, e.g.:</p>
<ul>
<li><a href="https://github.com/tokio-rs/tracing/tree/master/tracing-appender">https://github.com/tokio-rs/tracing/tree/master/tracing-appender</a> non-blocking log appender</li>
<li><a href="https://github.com/tokio-rs/tracing/tree/master/tracing-log">https://github.com/tokio-rs/tracing/tree/master/tracing-log</a> allows to forward library log statements and to use this in combination with env_logger</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="packaging"><a class="header" href="#packaging">Packaging</a></h1>
<p>For Rust native code, cargo works great, but we'll need to package stuff from outside of Rust too (e.g. tendermint). The goal is to have a repo that can always build as is (reproducible) and easily portable (having a single command to install all the deps).</p>
<p>Options to consider:</p>
<ul>
<li><a href="https://github.com/NixOS/nixpkgs">nix packages</a></li>
<li><a href="https://guix.gnu.org/manual/en/html_node/Package-Management.html">guix</a></li>
<li>docker</li>
</ul>
<h2 id="cargo"><a class="header" href="#cargo">Cargo</a></h2>
<p>For Rust dependencies, it would be nice to integrate and use:</p>
<ul>
<li><a href="https://github.com/crev-dev/cargo-crev">https://github.com/crev-dev/cargo-crev</a></li>
<li><a href="https://github.com/rust-secure-code/cargo-geiger">https://github.com/rust-secure-code/cargo-geiger</a></li>
<li><a href="https://github.com/kbknapp/cargo-outdated">https://github.com/kbknapp/cargo-outdated</a></li>
</ul>
<h2 id="nix"><a class="header" href="#nix">Nix</a></h2>
<p>Purely functional package management for reproducible environment. The big drawback is its language.</p>
<h2 id="guix"><a class="header" href="#guix">Guix</a></h2>
<p>Similar package management capability to nix, but using scheme language.</p>
<h2 id="docker"><a class="header" href="#docker">Docker</a></h2>
<p>Not ideal for development, but we'll probably want to provide docker images for users.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="serialization-libraries"><a class="header" href="#serialization-libraries">Serialization libraries</a></h1>
<p>Because the serialization for the RPC and storage have different priorities, it might be beneficial to use a different library for each.</p>
<h2 id="rpc"><a class="header" href="#rpc">RPC</a></h2>
<p>Important factors:</p>
<ul>
<li>security, e.g.:
<ul>
<li>handling of malicious input (buffers should not be trusted)</li>
<li>secure RPC, if included (e.g. DoS or memory exhaustion vulnerabilities)</li>
</ul>
</li>
<li>native and cross-language adoption for easy interop</li>
<li>ease of use</li>
<li>reasonable performance</li>
</ul>
<p>The considered libraries:</p>
<ul>
<li>protobuf</li>
<li>cap'n'proto</li>
<li>flatbuffers</li>
<li>serde</li>
</ul>
<p>The current preference is for protobuf using the prost library.</p>
<h2 id="storage-3"><a class="header" href="#storage-3">Storage</a></h2>
<p>Important factors:</p>
<ul>
<li>consistent binary representation for hashing</li>
<li>preserve ordering (for DB keys)</li>
<li>ease of use</li>
<li>reasonable performance</li>
</ul>
<p>The considered libraries:</p>
<ul>
<li>bincode</li>
<li>borsh</li>
</ul>
<h2 id="protobuf"><a class="header" href="#protobuf">Protobuf</a></h2>
<p>The most mature and widely adopted option. Usually combined with gRPC framework. The <a href="https://github.com/tendermint/rust-abci">Tendermint Rust ABCI</a> provides protobuf definitions.</p>
<p>Implementations:</p>
<ul>
<li><a href="https://github.com/danburkert/prost">https://github.com/danburkert/prost</a> - Rust native</li>
<li><a href="https://github.com/stepancheg/rust-protobuf">https://github.com/stepancheg/rust-protobuf</a> - Rust native</li>
<li><a href="https://github.com/tafia/quick-protobuf">https://github.com/tafia/quick-protobuf</a> - <a href="https://github.com/tafia/quick-protobuf/issues/12">missing features</a></li>
</ul>
<p><a href="https://www.reddit.com/r/rust/comments/czxny2/which_protocol_buffers_crates_to_invest_in/">A comparison of the two</a> main competing Rust implementations seems to favor Prost. Prost reportedly generates cleaner (more idiomatic) Rust code (<a href="https://hacks.mozilla.org/2019/04/crossing-the-rust-ffi-frontier-with-protocol-buffers/#comment-24671">https://hacks.mozilla.org/2019/04/crossing-the-rust-ffi-frontier-with-protocol-buffers/#comment-24671</a>). Prost also has better performance (<a href="https://github.com/danburkert/prost/issues/398#issuecomment-751600653">https://github.com/danburkert/prost/issues/398#issuecomment-751600653</a>). It is possible to also add serde derive attributes for e.g. <a href="https://github.com/danburkert/prost/issues/75">JSON support</a>. JSON can be useful for development, requests inspection and web integration. However, to reduce attack surface, we might want to disallow JSON for write requests on mainnet by default.</p>
<p>gRPC implementations:</p>
<ul>
<li><a href="https://github.com/hyperium/tonic">https://github.com/hyperium/tonic</a> - Rust native, using Prost and Tokio</li>
<li><a href="https://github.com/tikv/grpc-rs">https://github.com/tikv/grpc-rs</a> - build on C core library</li>
<li><a href="https://github.com/stepancheg/grpc-rust">https://github.com/stepancheg/grpc-rust</a> - not production ready</li>
</ul>
<h2 id="capnproto"><a class="header" href="#capnproto">Cap'n'proto</a></h2>
<p>It avoids serialization altogether, you use the data natively in a representation that is efficient for interchange (&quot;zero-copy&quot;). The other cool feature is its <a href="https://capnproto.org/rpc.html">&quot;time-traveling RPC&quot;</a>. On the other hand concern for this lib is a much lower adoption rate, especially the Rust port which is not as complete. The format is designed to be safe against malicious input (on the both sides of a communication channel), but according to <a href="https://capnproto.org/faq.html">FAQ</a> the reference impl (C++) has not yet undergone security review.</p>
<p>Implementations:</p>
<ul>
<li><a href="https://github.com/capnproto/capnproto-rust">https://github.com/capnproto/capnproto-rust</a></li>
</ul>
<h2 id="flatbuffers"><a class="header" href="#flatbuffers">Flatbuffers</a></h2>
<p>Similar to protobuf, but zero-copy like Cap'n'proto, hence a lot faster.</p>
<p>Unfortunately, the Rust implementation is <a href="https://google.github.io/flatbuffers/flatbuffers_support.html">lacking buffer verifiers</a>, which is crucial for handling malicious requests gracefully. There is only draft implementation <a href="https://github.com/google/flatbuffers/pull/6269">https://github.com/google/flatbuffers/pull/6269</a>. This most likely rules out this option.</p>
<p>Implementations:</p>
<ul>
<li><a href="https://github.com/google/flatbuffers/tree/master/rust/flatbuffers">https://github.com/google/flatbuffers/tree/master/rust/flatbuffers</a></li>
</ul>
<h2 id="serde"><a class="header" href="#serde">Serde</a></h2>
<p>Serde is Rust native framework with great ergonomics. It supports many <a href="https://serde.rs/#data-formats">different formats</a> implemented as libraries. It's used in some DBs too. Serde itself gives <a href="https://github.com/serde-rs/serde/issues/1087">no security guarantees</a>, handling of malicious input depends heavily on the used format. Serde can be used in combination with many other formats, like protobuf.</p>
<h2 id="bincode"><a class="header" href="#bincode">Bincode</a></h2>
<p><a href="https://github.com/servo/bincode">https://github.com/servo/bincode</a></p>
<p>Built on top of serde. Easy to use.</p>
<h2 id="borsh"><a class="header" href="#borsh">Borsh</a></h2>
<p><a href="https://github.com/near/borsh-rs">https://github.com/near/borsh-rs</a></p>
<p>Used in the Near protocol, it guarantees consistent representations and has a specification. It is also faster than bincode and is being <a href="https://github.com/near/borsh#implementations">implemented in other languages</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasm-runtime"><a class="header" href="#wasm-runtime">WASM runtime</a></h1>
<p>Considered runtimes:</p>
<ul>
<li>wasmer</li>
<li>wasmi</li>
</ul>
<p>A good comparison overview is given in this <a href="https://forum.holochain.org/t/wasmi-vs-wasmer/1929">thread that discusses replacing wasmi with wasmer</a> and its links. In summary:</p>
<ul>
<li>wasmer has native rust closures (simpler code)</li>
<li>wasmer uses lexical scoping to import functions, wasmi is based on structs and trait impls</li>
<li>the wasmer org maintains wasmer packages in many languages</li>
<li>wasmer may be vulnerable to compiler bombs
<ul>
<li>this can be mitigated by using <a href="https://lib.rs/crates/wasmer-compiler-singlepass-near">a singlepass wasm compiler</a></li>
</ul>
</li>
<li>gas metering
<ul>
<li>wasmi inject calls to the host gas meter from Wasm modules</li>
<li>wasmer 
<ul>
<li>uses Middleware which injects the instructions at the parsing stage of the compiler (with inlining) - reduced overhead</li>
<li>must also consider compiler gas cost and how to handle compiler performance changes</li>
</ul>
</li>
<li>it's hard to implement gas rules for precompiles</li>
</ul>
</li>
<li><a href="https://github.com/WebAssembly/design/blob/c9db0ebdee28d2f92726314c05cb8ff382701f8e/Nondeterminism.md">nondeterminism concerns</a>
<ul>
<li>different wasm versions (e.g. newly added features) have to be handled in both the compiled and interpreted versions</li>
<li>non-determinism in the source language cannot be made deterministic in complied/interpreted wasm either</li>
<li>threading - look like it has a long way to go before being usable</li>
<li>floats/NaN - can be avoided <a href="https://github.com/WebAssembly/design/issues/582#issuecomment-191318866">https://github.com/WebAssembly/design/issues/582#issuecomment-191318866</a></li>
<li>SIMD</li>
<li>environment resources exhaustion</li>
</ul>
</li>
<li>both are using the same spec, in wasmi words &quot;there shouldn't be a problem migrating to another spec compliant execution engine.&quot; and &quot;wasmi should be a good option for initial prototyping&quot;
<ul>
<li>of course this is only true if we don't use features that are not yet in the spec</li>
</ul>
</li>
</ul>
<h2 id="wasmer"><a class="header" href="#wasmer">wasmer</a></h2>
<p>Repo: <a href="https://github.com/wasmerio/wasmer">https://github.com/wasmerio/wasmer</a></p>
<p>Compiled with multiple backends (Singlepass, Cranelift and LLVM). It <a href="https://github.com/wasmerio/wasmer/blob/3dc537cc49b8034047c3b142a66b3b6180f4447c/examples/metering.rs">support metering</a> via a <a href="https://github.com/wasmerio/wasmer/tree/3dc537cc49b8034047c3b142a66b3b6180f4447c/lib/middlewares">Middleware</a>.</p>
<h2 id="wasmi"><a class="header" href="#wasmi">wasmi</a></h2>
<p>Repo: <a href="https://github.com/paritytech/wasmi">https://github.com/paritytech/wasmi</a></p>
<p>Built for blockchain to ensure high degree of correctness (security, determinism). Interpreted, hence slower.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-handling"><a class="header" href="#error-handling">Error handling</a></h1>
<p>The current preference is to use <code>thiserror</code> for most code and <code>eyre</code> for reporting errors at the CLI level and the client.</p>
<p>To make the code robust, we should avoid using code that may panic for errors that recoverable and handle all possible errors explicitly. Two exceptions to this rule are:</p>
<ul>
<li>prototyping, where it's fine to use <code>unwrap</code>, <code>expect</code>, etc.</li>
<li>in code paths with conditional compilation <strong>only</strong> for development build, where it's preferable to use <code>expect</code> in place of <code>unwrap</code> to help with debugging</li>
</ul>
<p>In case of panics, we should provide an error trace that is helpful for trouble-shooting and debugging.</p>
<p>A great post on error handling library/application distinction: <a href="https://nick.groenen.me/posts/rust-error-handling/">https://nick.groenen.me/posts/rust-error-handling/</a>.</p>
<p>The considered DBs:</p>
<ul>
<li>thiserror</li>
<li>anyhow</li>
<li>eyre</li>
</ul>
<p>The current preference is to use eyre at the outermost modules to print any encountered errors nicely back to the user and thiserror elsewhere.</p>
<h2 id="thiserror"><a class="header" href="#thiserror">Thiserror</a></h2>
<ul>
<li><a href="https://crates.io/crates/thiserror">https://crates.io/crates/thiserror</a></li>
</ul>
<p>Macros for user-derived error types. Commonly used for library code.</p>
<h2 id="anyhow"><a class="header" href="#anyhow">Anyhow</a></h2>
<ul>
<li><a href="https://crates.io/crates/anyhow">https://crates.io/crates/anyhow</a></li>
</ul>
<p>Easy error handling helpers. Commonly used for application code.</p>
<h2 id="eyre"><a class="header" href="#eyre">Eyre</a></h2>
<ul>
<li><a href="https://crates.io/crates/eyre">https://crates.io/crates/eyre</a></li>
</ul>
<p>Fork of <code>anyhow</code> with custom error reporting.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="glossary"><a class="header" href="#glossary">Glossary</a></h1>
<ul>
<li><strong>intent gossip</strong>
The intent gossip network must maintain a mempool of intents and gossips them
via a p2p layer. Each intent gossip node maintains a list of interests that
describe what intents it is interested in.</li>
<li><strong>intent</strong>
An expression of intent describes a particular trade an account agrees to.</li>
<li><strong>matchmaker</strong>
The matchmaker tries to match intents together. For each match it crafts a valid
transaction and submits it to the base ledger.</li>
<li><strong>validity predicate (VP)</strong>
A <a href="explore/design/ledger/vp.html">validity predicate</a> is a piece of code
attached to an account that can accept or reject any state changes performed by
a transaction in its sub-space.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="resources-1"><a class="header" href="#resources-1">Resources</a></h1>
<p>Please add anything relevant to the project that you'd like to share with others, such as research papers, blog posts or tutorials. If it's not obvious from the title, please add some description.</p>
<h2 id="general"><a class="header" href="#general">General</a></h2>
<ul>
<li><a href="https://github.com/rust-in-blockchain/awesome-blockchain-rust">https://github.com/rust-in-blockchain/awesome-blockchain-rust</a></li>
</ul>
<h2 id="rust"><a class="header" href="#rust">Rust</a></h2>
<ul>
<li><a href="https://github.com/mre/idiomatic-rust">https://github.com/mre/idiomatic-rust</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ide"><a class="header" href="#ide">IDE</a></h1>
<h2 id="vscode"><a class="header" href="#vscode">VsCode</a></h2>
<p>Some handy extensions (output of <code>code --list-extensions</code>):</p>
<pre><code class="language-shell">aaron-bond.better-comments
be5invis.toml
bodil.file-browser
bungcip.better-toml
DavidAnson.vscode-markdownlint
jacobdufault.fuzzy-search
kahole.magit
matklad.rust-analyzer
oderwat.indent-rainbow
# easy to see if crates are up-to-date and update if not
serayuzgur.crates
streetsidesoftware.code-spell-checker
vscodevim.vim
# this is like https://www.spacemacs.org/ but in VsCode
VSpaceCode.vspacecode
VSpaceCode.whichkey
# org-mode
vscode-org-mode.org-mode
publicus.org-checkbox
</code></pre>
<p>Add these to your settings.json to get rustfmt and clippy with the nightly version that we use:</p>
<pre><code class="language-json">&quot;rust-analyzer.checkOnSave.overrideCommand&quot;: [
    &quot;cargo&quot;,
    &quot;+nightly-2021-11-01&quot;,
    &quot;clippy&quot;,
    &quot;--workspace&quot;,
    &quot;--message-format=json&quot;,
    &quot;--all-targets&quot;
],
&quot;rust-analyzer.rustfmt.overrideCommand&quot;: [
    &quot;rustup&quot;,
    &quot;run&quot;,
    &quot;nightly-2021-11-01&quot;,
    &quot;--&quot;,
    &quot;rustfmt&quot;,
    &quot;--edition&quot;,
    &quot;2018&quot;,
    &quot;--&quot;
],
</code></pre>
<p>When editing the wasms source (i.e. <code>wasm/wasm_source/src/..</code>), open the <code>wasm/wasm_source</code> as a workspace to get rust-analyzer working (because the crate is excluded from the root cargo workspace) and then active <code>--all-features</code> for it in the preferences.</p>
<h2 id="emacs"><a class="header" href="#emacs">Emacs</a></h2>
<p>two main mode:</p>
<ul>
<li><a href="https://github.com/rust-lang/rust-mode">rust-mode</a>
official mode supported by rust dev</li>
<li><a href="https://github.com/brotzeit/rustic">rustic-mode</a>
forked with more option and better integration/default value</li>
</ul>
<h2 id="config-example-with-rustic-and-use-package"><a class="header" href="#config-example-with-rustic-and-use-package">config example with rustic and use-package</a></h2>
<pre><code class="language-elisp">    ;; all flycheck not mandatory not mandatory
  (use-package flycheck
    :commands flycheck-mode
    :init (global-flycheck-mode))

  (use-package flycheck-color-mode-line
    :after flycheck
    :hook
    (flycheck-mode . flycheck-color-mode-line-mode))

  (use-package flycheck-pos-tip
    :after flycheck)
  (use-package lsp-mode
    :after flycheck
    :bind-keymap
    (&quot;C-c i&quot; .  lsp-command-map)
    :hook
    (lsp-mode . lsp-enable-which-key-integration) ;; if wichkey installed
    :commands (lsp lsp-deferred)
    :custom
    (lsp-eldoc-render-all t)
    (lsp-idle-delay 0.3)
    )

  (use-package lsp-ui
    :after lsp-mode
    :commands lsp-ui-mode
    :custom
    (lsp-ui-peek-always-show t)
    (lsp-ui-sideline-show-hover t)
    (lsp-ui-doc-enable nil)
    (lsp-ui-doc-max-height 30)
    :hook (lsp-mode . lsp-ui-mode))

    ;; if ivy installed installed
  (use-package lsp-ivy
    :after lsp-mode ivy
    :commands lsp-ivy-workspace-symbol)

    ;; if company installed
  (use-package company-lsp
    :after lsp-mode company
    :init
    (push 'company-lsp company-backend))

  (use-package rustic
    :bind (:map rustic-mode-map
                (&quot;M-j&quot; . lsp-ui-imenu)
                (&quot;M-?&quot; . lsp-find-references)
                (&quot;C-c C-c ?&quot; . lsp-describe-thing-at-point)
                (&quot;C-c C-c !&quot; . lsp-execute-code-action)
                (&quot;C-c C-c r&quot; . lsp-rename)
                (&quot;C-c C-c TAB&quot; . lsp-rust-analyzer-expand-macro)
                (&quot;C-c C-c q&quot; . lsp-workspace-restart)
                (&quot;C-c C-c Q&quot; . lsp-workspace-shutdown)
                (&quot;C-c C-c s&quot; . lsp-rust-analyzer-status)
                (&quot;C-c C-c C-a&quot; . rustic-cargo-add)
                (&quot;C-c C-c C-d&quot; . rustic-cargo-rm)
                (&quot;C-c C-c C-u&quot; . rustic-cargo-upgrade)
                (&quot;C-c C-c C-u&quot; . rustic-cargo-outdated))
    :hook
    (rustic-mode . lsp-deferred)
    :custom
    (lsp-rust-analyzer-cargo-watch-command &quot;clippy&quot;)
    :config
    (rustic-doc-mode t)
  )
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="specifications"><a class="header" href="#specifications">Specifications</a></h1>
<p><a href="https://anoma.network/papers/whitepaper.pdf">Anoma</a> is a sovereign, proof-of-stake blockchain protocol that enables private, asset-agnostic cash and private bartering among any number of parties.</p>
<p>This specification defines the Anoma ledger's protocol and its components and the intent gossip and matchmaking system.</p>
<p>The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;,  &quot;MAY&quot;, and &quot;OPTIONAL&quot; in this document are to be interpreted as described in <a href="https://www.rfc-editor.org/rfc/rfc2119">RFC-2119</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overview-2"><a class="header" href="#overview-2">Overview</a></h1>
<p>At a high level, Anoma is composed of two main components: the distributed ledger and the intent gossip / matchmaking system. While they are designed to complement each other, they can be operated separately.</p>
<h2 id="the-ledger-1"><a class="header" href="#the-ledger-1">The ledger</a></h2>
<p>The <a href="specs/ledger.html">ledger</a> is a distributed state machine, relying on functionality provided by <a href="https://docs.tendermint.com/master/spec/">Tendermint</a> such as its BFT consensus algorithm with instant finality, P2P networking capabilities, transaction mempool and more. The ledger state machine is built on top the <a href="https://docs.tendermint.com/master/spec/abci/">ABCI</a>.</p>
<p>For block validator voting power assignment, the ledger employs a proof-of-stake system.</p>
<p>The ledger's key-value storage is organized into blocks and user specific state is organized into accounts. The state machine executes transactions, which can apply arbitrary changes to the state that are validated by validity predicates associated with the accounts involved in the transaction.</p>
<p>To prevent transaction front-running, the ledger employs a DKG scheme as implemented in <a href="https://github.com/anoma/ferveo">Ferveo</a>. Using this scheme, transactions are encrypted before being submitted to the ledger. The encrypted transactions are committed by a block proposer to a specific order in which they must be executed once decrypted.</p>
<ul>
<li>TODO add fractal scaling &amp; protocol upgrade system overview</li>
</ul>
<h2 id="the-intent-gossip-with-matchmaking-system"><a class="header" href="#the-intent-gossip-with-matchmaking-system">The intent gossip with matchmaking system</a></h2>
<ul>
<li>TODO add an overview</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-ledger-2"><a class="header" href="#the-ledger-2">The ledger</a></h1>
<p>The ledger's main responsibility is to process and apply <a href="specs/ledger.html#transactions">transactions</a> over the <a href="specs/ledger.html#storage">distributed ledger's storage</a>, following the ledger's <a href="specs/ledger.html#the-protocol">protocol</a> to reach consensus.</p>
<h2 id="accounts-1"><a class="header" href="#accounts-1">Accounts</a></h2>
<p>The ledger is backed by an account-based system. Each account has a unique <a href="specs/ledger.html#addresses">address</a> and exactly one <a href="specs/ledger.html#validity-predicates-check">validity predicate</a> and a <a href="specs/ledger.html#dynamic-storage-sub-space">dynamic storage sub-space</a>.</p>
<h3 id="addresses"><a class="header" href="#addresses">Addresses</a></h3>
<p>There are two main types of address: transparent and shielded.</p>
<p>The transparent addresses are the addresses of accounts associated with dynamic storage sub-spaces, where the address of the account is the prefix key segment of its sub-space.</p>
<p>The shielded addresses are used for private transactions and they are not directly associated with storage sub-spaces.</p>
<h4 id="transparent-addresses"><a class="header" href="#transparent-addresses">Transparent addresses</a></h4>
<p>Furthermore, there are three types of transparent addresses:</p>
<ul>
<li>&quot;implicit&quot; addresses which are derived from <a href="specs/crypto.html#public-keys">public keys</a></li>
<li>&quot;established&quot; addresses which are generated from the current address nonce and hence must be created via a request in the ledger</li>
<li>&quot;internal&quot; addresses are used for special modules integrated into the ledger such as PoS and IBC.</li>
</ul>
<p>The addresses are stored on-chain encoded with <a href="https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki">bech32m</a>, which is an improved version of <a href="https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki">bech32</a>.</p>
<p>The human-readable prefix (as specified for <a href="https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki#specification">bech32</a>) in the transparent address encoding is:</p>
<ul>
<li><code>&quot;a&quot;</code> for Anoma live network (80 characters in total)</li>
<li><code>&quot;atest&quot;</code> for test networks (84 characters in total)</li>
</ul>
<h2 id="transactions-2"><a class="header" href="#transactions-2">Transactions</a></h2>
<p>A transaction has two layers, each wrapped inside <a href="specs/./encoding.html#transactions"><code>Tx</code> type encoded with proto3</a>.</p>
<p>The outer layer is employed for front-running protection following DKG protocol to wrap the inner layer, which remains encrypted before its block order has been committed. The outer layer MUST contain <code>data</code> with a <a href="specs/encoding.html#txtype"><code>TxType::Wrapper</code></a> that has a <a href="specs/encoding.html#wrappertx"><code>WrapperTx</code></a> inside it.</p>
<p>The SHA-256 hash of this data <a href="specs/encoding.html#borsh-binary-encoding">encoded with Borsh</a> MUST be <a href="specs/crypto.html#signatures">signed</a> by an implicit account's key. The encoded signed data together with the signature should be encoded as a <a href="specs/encoding.html#signedtxdata"><code>SignedTxData</code></a> and also encoded with Borsh. This data should then be attached to a protobuf encoded transaction's <code>data</code> field and the field <code>code</code> in this layer MUST be empty. Note that the outer layer's signature is not relevant to the inner layer of the transaction, only itself.</p>
<p>The fields of a <code>WrapperTx</code> are:</p>
<ul>
<li>
<p><code>fee</code>: Fee to be payed by the source implicit account for including the tx in a block.</p>
</li>
<li>
<p><code>pk</code>: <a href="specs/crypto.html#public-keys">Public key</a> of the source implicit account.</p>
</li>
<li>
<p><code>epoch</code>: The <a href="specs/ledger.html#epochs">epoch</a> in which the transaction is being included. This should be queried from a synchronized ledger node before the transaction is fully constructed.</p>
<p>Note that this is currently not used and so the default value <code>0</code> may be used for now (depends on <a href="https://github.com/anoma/anoma/issues/669">https://github.com/anoma/anoma/issues/669</a>).</p>
</li>
<li>
<p><code>gas_limit</code>: Maximum amount of gas that can be used when executing the inner transaction</p>
</li>
<li>
<p><code>inner_tx</code>: The inner layer of the transaction. This MUST contain a <a href="specs/./encoding.html#transactions"><code>Tx</code> type encoded with proto3</a>, encrypted against a public key that should be queried from a synchronized ledger node.</p>
<p>The inner transaction's <code>Tx</code> MUST contain the WASM code to be executed and optionally any <code>data</code> (which will be provided to the transaction and any triggered validity predicates when they're invoked) to be executed and applied in a block (for example the <a href="specs/ledger/default-transactions.html">default transactions</a>).</p>
<p>Please refer to the <a href="specs/ledger/default-transactions.html#signing-transactions">signing of the default transactions</a> to learn how to construct inner transaction's signatures which will be accepted by the <a href="specs/ledger/default-validity-predicates.html">default validity predicates</a>.</p>
<p>Note that currently the key doesn't change and so it stay constant for the duration of a chain and <code>&lt;EllipticCurve as PairingEngine&gt;::G1Affine::prime_subgroup_generator()</code> may be used to encrypt the inner transaction for now as done by the the <a href="https://dev.anoma.net/master/rustdoc/anoma/types/transaction/wrapper/wrapper_tx/struct.WrapperTx.html#method.new"><code>WrapperTx::new</code> method</a> (depends on <a href="https://github.com/anoma/anoma/issues/669">https://github.com/anoma/anoma/issues/669</a>).</p>
</li>
<li>
<p><code>tx_hash</code>: A SHA-256 hash of the inner transaction. This MUST match the hash of decrypted <code>inner_tx</code>.</p>
</li>
</ul>
<p>TODO: wrapper transactions will include replay protection (this is because we can simply check a counter against the source (i.e. gas payer) of the transaction before the transactions order is committed to by the DKG protocol, which could affect the expected counter order for sources with multiple queued transactions)</p>
<h2 id="the-protocol"><a class="header" href="#the-protocol">The protocol</a></h2>
<p>When a tx is added to the <a href="specs/ledger.html#mempool">mempool</a> and included in block by a block proposer, the <a href="specs/ledger.html#outer-transaction-processing">outer transaction is processed</a> and if valid, its inner transaction is added to a transaction FIFO queue that MUST be in the same order as the outer transactions.</p>
<p>An inner transaction popped from the queue is applied in a block executed in two main steps:</p>
<ol>
<li><a href="specs/ledger.html#inner-transaction-execution">Inner transaction execution</a></li>
<li><a href="specs/ledger.html#validity-predicates-check">Validity predicates check</a></li>
</ol>
<h3 id="epochs-1"><a class="header" href="#epochs-1">Epochs</a></h3>
<p>An epoch is a range of blocks whose length is determined by the <a href="specs/ledger.html#protocol-parameters">epoch duration protocol parameter</a>: minimum epoch duration and minimum number of blocks in an epoch. They are identified by consecutive natural numbers starting at 0. The <a href="specs/encoding.html#epoch">Borsh encoded <code>Epoch</code></a> for the last committed block can be queried via the <a href="specs/ledger/rpc.html#read-only-queries">RPC</a>.</p>
<h3 id="protocol-parameters"><a class="header" href="#protocol-parameters">Protocol parameters</a></h3>
<p>The parameters are used to dynamically control certain variables in the protocol. They are implemented as an internal address with a native validity predicate. The current value of <a href="specs/encoding.html#parameters">Borsh encoded <code>Parameters</code></a> is written into and read from the block storage in the parameters account's sub-space.</p>
<p>Initial parameters for a chain are set in the genesis configuration.</p>
<h4 id="epoch-duration-1"><a class="header" href="#epoch-duration-1">Epoch duration</a></h4>
<p>The parameters for <a href="specs/ledger.html#epochs">epoch</a> duration are:</p>
<ul>
<li>Minimum number of blocks in an epoch</li>
<li>Minimum duration of an epoch</li>
</ul>
<h3 id="mempool-1"><a class="header" href="#mempool-1">Mempool</a></h3>
<p>When a request to add a transaction to the mempool is received, it will only be added it's a <a href="specs/./encoding.html#transactions"><code>Tx</code> encoded with proto3</a>.</p>
<h3 id="outer-transaction-processing"><a class="header" href="#outer-transaction-processing">Outer transaction processing</a></h3>
<p>TODO: describe outer tx fee check and deduction, inner tx decryption, tx queue up to the inner tx execution</p>
<h3 id="inner-transaction-execution"><a class="header" href="#inner-transaction-execution">Inner transaction execution</a></h3>
<p>For any error encountered in any of the following steps of transaction execution, the protocol MUST charge the gas used by the transaction and discard any storage changes that the transaction attempted to perform.</p>
<ol>
<li>
<p>Charge a base transaction <a href="specs/ledger.html#gas">gas</a>:
\( \verb|BASE_TRANSACTION_FEE| \)</p>
</li>
<li>
<p>Decode the transaction bytes and validate the data. The field <code>timestamp</code> is required.</p>
</li>
<li>
<p>Charge WASM compilation gas, proportional to the bytes <code>length</code> of the <code>code</code> field of the transaction (this is because the WASM code is compiled with a single-pass compiler):
\( \verb|length| * \verb|COMPILE_GAS_PER_BYTE| \)</p>
</li>
<li>
<p><a href="specs/ledger.html#wasm-validation">Validate the WASM code</a> from the <code>code</code> field of the transaction.</p>
</li>
<li>
<p>Inject a <a href="specs/ledger.html#gas">gas counter</a> into the <code>code</code>.</p>
</li>
<li>
<p>Inject a <a href="specs/ledger.html#stack-height-limiter">stack height</a> limiter into the <code>code</code>.</p>
</li>
<li>
<p>Compile the transaction <code>code</code> with a single-pass compiler (for example, <a href="https://medium.com/wasmer/a-webassembly-compiler-tale-9ef37aa3b537">the Wasmer runtime single-pass compiler</a>). The compilation computational complexity MUST be linear in proportion to the <code>code</code> size.</p>
</li>
<li>
<p>Initialize the WASM linear memory with descriptor having the initial memory size equal to <a href="specs/ledger.html#wasm-constants"><code>TX_MEMORY_INIT_PAGES</code></a> and maximum memory size to <a href="specs/ledger.html#wasm-constants"><code>TX_MEMORY_MAX_PAGES</code></a>.</p>
</li>
<li>
<p>Instantiate the WASM module with imported <a href="specs/ledger.html#transaction-host-environment-functions">transaction host environment functions</a> and the instantiated WASM memory.</p>
</li>
<li>
<p>Write the transaction's <code>data</code> into the memory exported from the WASM module instance.</p>
</li>
<li>
<p>Attempt to call the module's entrypoint function. The entrypoint MUST have signature:</p>
<pre><code class="language-wat">func (param i64 i64)
</code></pre>
<p>The first argument is the offset to the <code>data</code> input written into the memory and the second argument is its bytes length.</p>
</li>
</ol>
<p>If the transaction executed successfully, it is followed <a href="specs/ledger.html#validity-predicates-check">Validity predicates check</a>.</p>
<h3 id="validity-predicates-check"><a class="header" href="#validity-predicates-check">Validity predicates check</a></h3>
<p>For the transaction to be valid, all the triggered validity predicates must accept it.</p>
<p>First, the addresses whose validity predicates should be triggered by the transaction are determined:</p>
<ol>
<li>The addresses set by the transaction (see <code>insert_verifier</code> in <a href="specs/ledger.html#transaction-host-environment-functions">transaction host environment functions</a>) are included in the verifiers set.</li>
<li>The storage keys that were modified by the transaction are inspected for addresses included in the storage key segments and these are also included in the verifiers set. Note that a storage key may contain more than one address, in which case all its addresses are included. This however excludes addresses of established accounts that were initialized in this transaction as they do not exist prior to transaction execution and a validity predicate will be associated with an initialized account only after the transaction is applied and accepted. This is intended as it allows users to initialize their account's storage without a validity predicate check.</li>
</ol>
<p>For all these addresses, attempt to read their validity predicate WASM code from the storage. For each validity predicate look-up, charge storage read gas and WASM compilation gas, proportional to the bytes length of the validity predicate. If any of the validity predicates look-ups fails, or any validity rejects the transaction or fails anywhere in the execution, the whole transaction is rejected. If the transaction is rejected, the protocol MUST charge the gas used by the transaction and discard any storage changes that the transaction attempted to perform.</p>
<p>Execute all validity predicates in parallel as follows:</p>
<ol>
<li>
<p>Charge WASM compilation gas, proportional to the bytes length of the validity predicate (same as for the transaction, WASM code is compiled with a single-pass compiler).</p>
</li>
<li>
<p>Charge WASM compilation gas, proportional to the bytes <code>length</code> of the validity predicate (same as for the transaction, WASM code is compiled with a single-pass compiler): \( \verb|length| * \verb|COMPILE_GAS_PER_BYTE| \).</p>
</li>
<li>
<p><a href="specs/ledger.html#wasm-validation">Validate the WASM code</a> of the validity predicate.</p>
</li>
<li>
<p>Inject a <a href="specs/ledger.html#gas">gas counter</a> into the <code>code</code>.</p>
</li>
<li>
<p>Inject a <a href="specs/ledger.html#stack-height-limiter">stack height</a> limiter into the <code>code</code>.</p>
</li>
<li>
<p>Compile the validity predicate with single-pass compiler. The compilation computational complexity MUST be linear in proportion to its bytes size.</p>
</li>
<li>
<p>Initialize the WASM linear memory with descriptor having the initial memory size equal to <a href="specs/ledger.html#wasm-constants"><code>VP_MEMORY_INIT_PAGES</code></a> and maximum memory size to <a href="specs/ledger.html#wasm-constants"><code>VP_MEMORY_MAX_PAGES</code></a>.</p>
</li>
<li>
<p>Instantiate the WASM module with imported <a href="specs/ledger.html#validity-predicate-host-environment-functions">validity predicate host environment functions</a> and the instantiated WASM memory.</p>
</li>
<li>
<p>Write the address of the validity predicate’s owner, the transaction <code>data</code>, the modified storage keys encoded with Borsh, and all the triggered validity predicates owners' addresses encoded with Borsh into the memory exported from the WASM module instance.</p>
</li>
<li>
<p>Attempt to call the module's entrypoint function. The entrypoint MUST have signature:</p>
<pre><code class="language-wat">func (param i64 i64 i64 i64 i64 i64 i64 i64) (result i64))
</code></pre>
<ul>
<li>The first argument is the offset to the owner’s address written into the memory, the second argument is its bytes length</li>
<li>The third is the offset of the transaction’s <code>data</code> and fourth is it’s bytes length</li>
<li>The fifth is the offset of the modified storage keys and sixth is its bytes length</li>
<li>The seventh is the offset of the triggered validity predicates owners' addresses and eighth is its bytes length</li>
</ul>
</li>
</ol>
<h3 id="gas"><a class="header" href="#gas">Gas</a></h3>
<h4 id="gas-constants"><a class="header" href="#gas-constants">Gas constants</a></h4>
<p>The gas constants are currently chosen arbitrarily and are subject to change following gas accounting estimations.</p>
<table><thead><tr><th>Name</th><th>Value</th></tr></thead><tbody>
<tr><td><code>COMPILE_GAS_PER_BYTE</code></td><td>1</td></tr>
<tr><td><code>BASE_TRANSACTION_FEE</code></td><td>2</td></tr>
<tr><td><code>PARALLEL_GAS_DIVIDER</code></td><td>10</td></tr>
<tr><td><code>MIN_STORAGE_GAS</code></td><td>1</td></tr>
</tbody></table>
<ul>
<li>TODO describe gas accounting, wasm gas counter, limits, what happens if we go over limits and how gas relates to fees</li>
</ul>
<h3 id="webassembly-wasm"><a class="header" href="#webassembly-wasm">WebAssembly (WASM)</a></h3>
<h4 id="wasm-constants"><a class="header" href="#wasm-constants">WASM constants</a></h4>
<table><thead><tr><th>Name</th><th>Unit</th><th>Value</th></tr></thead><tbody>
<tr><td><code>PAGE</code> (as defined in the WASM spec)</td><td>kiB</td><td>64</td></tr>
<tr><td><code>TX_MEMORY_INIT_PAGES</code></td><td>number of <code>PAGE</code>s</td><td>100</td></tr>
<tr><td><code>TX_MEMORY_MAX_PAGES</code></td><td>number of <code>PAGE</code>s</td><td>200</td></tr>
<tr><td><code>VP_MEMORY_INIT_PAGES</code></td><td>number of <code>PAGE</code>s</td><td>100</td></tr>
<tr><td><code>VP_MEMORY_MAX_PAGES</code></td><td>number of <code>PAGE</code>s</td><td>200</td></tr>
<tr><td><code>WASM_STACK_LIMIT</code></td><td>stack depth</td><td>65535</td></tr>
</tbody></table>
<p>The WASM instantiation, the types, instructions, validation and execution of WASM modules MUST conform to the <a href="https://webassembly.github.io/spec/core/intro/index.html">WebAssembly specification</a>.</p>
<h4 id="wasm-validation"><a class="header" href="#wasm-validation">WASM validation</a></h4>
<p>The WebAssembly code is REQUIRED to only use deterministic instructions. Furthermore, it MUST NOT use features from any of the following WebAssembly proposals:</p>
<ul>
<li>The reference types proposal</li>
<li>The multi-value proposal</li>
<li>The bulk memory operations proposal</li>
<li>The module linking proposal</li>
<li>The SIMD proposal</li>
<li>The threads proposal</li>
<li>The tail-call proposal</li>
<li>The multi memory proposal</li>
<li>The exception handling proposal</li>
<li>The memory64 proposal</li>
</ul>
<h4 id="stack-height-limiter"><a class="header" href="#stack-height-limiter">Stack height limiter</a></h4>
<p>To make stack overflows deterministic, set the upper bound of the stack size to <a href="specs/ledger.html#wasm-constants"><code>WASM_STACK_LIMIT</code></a>. If the stack height exceeds the limit then execution MUST abort.</p>
<!--
cargo test test_tx_stack_limiter
cargo test test_vp_stack_limiter
-->
<h4 id="wasm-memory-1"><a class="header" href="#wasm-memory-1">WASM memory</a></h4>
<ul>
<li>TODO memory read/write gas costs</li>
</ul>
<h4 id="transaction-host-environment-functions"><a class="header" href="#transaction-host-environment-functions">Transaction host environment functions</a></h4>
<p>The following functions from the host ledger are made available in transaction's WASM code. They MAY be imported in the WASM module as shown bellow and MUST be provided by the ledger's WASM runtime:</p>
<pre><code class="language-wat">(import &quot;env&quot; &quot;gas&quot; (func (param i32)))
(import &quot;env&quot; &quot;anoma_tx_read&quot; (func (param i64 i64) (result i64)))
(import &quot;env&quot; &quot;anoma_tx_result_buffer&quot; (func (param i64)))
(import &quot;env&quot; &quot;anoma_tx_has_key&quot; (func (param i64 i64) (result i64)))
(import &quot;env&quot; &quot;anoma_tx_write&quot; (func (param i64 i64 i64 i64)))
(import &quot;env&quot; &quot;anoma_tx_delete&quot; (func (param i64 i64)))
(import &quot;env&quot; &quot;anoma_tx_iter_prefix&quot; (func (param i64 i64) (result i64)))
(import &quot;env&quot; &quot;anoma_tx_iter_next&quot; (func (param i64) (result i64)))
(import &quot;env&quot; &quot;anoma_tx_insert_verifier&quot; (func (param i64 i64)))
(import &quot;env&quot; &quot;anoma_tx_update_validity_predicate&quot; (func (param i64 i64 i64 i64)))
(import &quot;env&quot; &quot;anoma_tx_init_account&quot; (func (param i64 i64 i64)))
(import &quot;env&quot; &quot;anoma_tx_get_chain_id&quot; (func (param i64)))
(import &quot;env&quot; &quot;anoma_tx_get_block_height&quot; (func (param ) (result i64)))
(import &quot;env&quot; &quot;anoma_tx_get_block_hash&quot; (func (param i64)))
(import &quot;env&quot; &quot;anoma_tx_log_string&quot; (func (param i64 i64)))
</code></pre>
<p>Additionally, the WASM module MUST export its memory as shown:</p>
<pre><code class="language-wat">(export &quot;memory&quot; (memory 0))
</code></pre>
<ul>
<li><code>anoma_tx_init_account</code> TODO newly created accounts' validity predicates aren't used until the block is committed (i.e. only the transaction that created the account may write into its storage in the block in which its being applied).</li>
<li>TODO describe functions in detail</li>
</ul>
<h4 id="validity-predicate-host-environment-functions"><a class="header" href="#validity-predicate-host-environment-functions">Validity predicate host environment functions</a></h4>
<p>The following functions from the host ledger are made available in validity predicate's WASM code. They MAY be imported in the WASM module as shown bellow and MUST be provided by the ledger's WASM runtime.</p>
<pre><code class="language-wat">(import &quot;env&quot; &quot;gas&quot; (func (param i32)))
(import &quot;env&quot; &quot;anoma_vp_read_pre&quot; (func (param i64 i64) (result i64)))
(import &quot;env&quot; &quot;anoma_vp_read_post&quot; (func (param i64 i64) (result i64)))
(import &quot;env&quot; &quot;anoma_vp_result_buffer&quot; (func (param i64)))
(import &quot;env&quot; &quot;anoma_vp_has_key_pre&quot; (func (param i64 i64) (result i64)))
(import &quot;env&quot; &quot;anoma_vp_has_key_post&quot; (func (param i64 i64) (result i64)))
(import &quot;env&quot; &quot;anoma_vp_iter_prefix&quot; (func (param i64 i64) (result i64)))
(import &quot;env&quot; &quot;anoma_vp_iter_pre_next&quot; (func (param i64) (result i64)))
(import &quot;env&quot; &quot;anoma_vp_iter_post_next&quot; (func (param i64) (result i64)))
(import &quot;env&quot; &quot;anoma_vp_get_chain_id&quot; (func (param i64)))
(import &quot;env&quot; &quot;anoma_vp_get_block_height&quot; (func (param ) (result i64)))
(import &quot;env&quot; &quot;anoma_vp_get_block_hash&quot; (func (param i64)))
(import &quot;env&quot; &quot;anoma_vp_verify_tx_signature&quot; (func (param i64 i64 i64 i64) (result i64)))
(import &quot;env&quot; &quot;anoma_vp_eval&quot; (func (param i64 i64 i64 i64) (result i64)))
</code></pre>
<ul>
<li>TODO describe functions in detail</li>
</ul>
<p>Additionally, the WASM module MUST export its memory as shown:</p>
<pre><code class="language-wat">(export &quot;memory&quot; (memory 0))
</code></pre>
<h3 id="storage-4"><a class="header" href="#storage-4">Storage</a></h3>
<ul>
<li>TODO dynamic key-value storage paths, encoding agnostic, any ledger native keys such as the VP key</li>
<li>TODO VPs must be written into the storage as raw bytes without any additional encoding</li>
</ul>
<h4 id="storage-keys"><a class="header" href="#storage-keys">Storage keys</a></h4>
<ul>
<li>TODO spec the key segments, punct, reserved VP segment <code>?</code> and address prefix <code>#</code></li>
</ul>
<h4 id="dynamic-storage-sub-space-1"><a class="header" href="#dynamic-storage-sub-space-1">Dynamic storage sub-space</a></h4>
<p>Each account can have an associated dynamic account state in the storage. This
state may be comprised of keys with a format specified above and values of arbitrary user bytes. The first segment of all the keys must be the account's address.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rpc-1"><a class="header" href="#rpc-1">RPC</a></h1>
<p>The ledger provides an RPC interface for submitting transactions to the mempool, subscribing to their results and queries about the state of the ledger and its storage.</p>
<p>The RPC interface is provided as <a href="https://github.com/tendermint/spec/tree/4566f1e3028278c5b3eca27b53254a48771b152b/spec/rpc">specified</a> from Tendermint and most of the requests are routed to the Anoma ledger via ABCI.</p>
<h2 id="transactions-3"><a class="header" href="#transactions-3">Transactions</a></h2>
<p>A <a href="specs/ledger/../ledger.html#transactions">transaction</a> can be submitted to the <a href="specs/ledger/../ledger.html#mempool">mempool</a> via Tendermint's <a href="https://github.com/tendermint/spec/tree/4566f1e3028278c5b3eca27b53254a48771b152b/spec/rpc#broadcasttxsync"><code>BroadCastTxSync</code></a> or <a href="https://github.com/tendermint/spec/tree/4566f1e3028278c5b3eca27b53254a48771b152b/spec/rpc#broadcasttxasync"><code>BroadCastTxAsync</code></a>. The <code>CheckTx</code> result of these requests is success only if the transaction passes <a href="specs/ledger/../ledger.html#mempool">mempool validation rules</a>. In case of <code>BroadCastTxAsync</code>, the <code>DeliverTx</code> is not indicative of the transaction's result, it's merely a result of the transaction being added to the <a href="specs/ledger/../ledger.html#outer-transaction-processing">transaction queue</a>. The actual result of the outer transaction and the inner transaction can be found from via the <a href="https://github.com/tendermint/spec/blob/4566f1e3028278c5b3eca27b53254a48771b152b/spec/abci/abci.md#events">ABCI events</a>.</p>
<p>To find a result of the inner transaction, query for event with <code>type</code> equal to <code>&quot;NewBlock&quot;</code> and key equal to <code>&quot;applied.hash&quot;</code>, where the <code>value</code> of the found <code>Event</code> will contain <code>TxResult</code> pretty-printed as a string (TODO proper encoding depends on <a href="https://github.com/anoma/anoma/issues/455">https://github.com/anoma/anoma/issues/455</a>).</p>
<h2 id="read-only-queries"><a class="header" href="#read-only-queries">Read-only queries</a></h2>
<p>Read-only queries can be requested via <a href="https://github.com/tendermint/spec/tree/4566f1e3028278c5b3eca27b53254a48771b152b/spec/rpc#abciquery">ABCIQuery</a>. The <code>path</code> for the query can be one of the following options:</p>
<ul>
<li><code>epoch</code>: Get the <a href="specs/ledger/../ledger.html#epochs">epoch</a> of the last committed block. The response <code>value</code> is always known <a href="specs/ledger/../encoding.html#epoch">Borsh encoded <code>Epoch</code></a></li>
<li><code>dry_run_tx</code>: Simulate a transaction being applied in a block. The response <code>code = 0</code> means that the transaction would be accepted by all the validity predicates that verified its validity. On success, the response <code>info</code> contains the <code>TxResult</code> pretty-printed as a string (TODO proper encoding depends on <a href="https://github.com/anoma/anoma/issues/455">https://github.com/anoma/anoma/issues/455</a>).</li>
<li><code>value/{dynamic}</code>: Look-up a raw <a href="specs/ledger/../ledger.html#storage">storage</a> value for the given <code>dynamic</code> key. When the response <code>code = 0</code>, the key is found and the response <code>value</code> contains the raw bytes of the value.</li>
<li><code>prefix/{dynamic}</code>: Iterate a <a href="specs/ledger/../ledger.html#storage">storage</a> key prefix for the given <code>dynamic</code> key. When the response <code>code = 0</code>, the key is found and the response <code>value</code> contains <a href="specs/ledger/../encoding.html#prefixvalue">Borsh encoded <code>Vec&lt;PrefixValue&gt;</code></a>, where each <code>PrefixValue</code> contains the <code>key</code> and the raw bytes of the <code>value</code>.</li>
<li><code>has_key/{dynamic}</code>: check if the given <code>dynamic</code> key is present in the <a href="specs/ledger/../ledger.html#storage">storage</a>. The response <code>value</code> contains <a href="specs/ledger/../encoding.html#borsh-binary-encoding">Borsh encoded</a> boolean that is <code>true</code> if the key has been found.</li>
</ul>
<p>For example, to find if an established address exists on-chain, we can submit a query to find if it has a validity predicate at path <code>has_key/#{established_address}/?</code>, which is the only storage value required for established addresses (note that <code>#</code> is a special storage key segment prefix for bech32m encoded addresses and <code>?</code> character is used as the last segment of a validity predicate storage key).</p>
<h2 id="pos"><a class="header" href="#pos">PoS</a></h2>
<p>TODO document response types encoding after <a href="https://github.com/anoma/anoma/issues/439">https://github.com/anoma/anoma/issues/439</a></p>
<p>The Proof-of-Stake queries are built on top of the <a href="specs/ledger/rpc.html#read-only-queries">read-only queries</a>, where all the PoS data are stored under the <a href="specs/ledger/../encoding.html#internaladdress">internal <code>PoS</code> address</a>, which is governed by its native validity predicate. The bech32m encoded address of the PoS account currently is <code>&quot;atest1v9hx7w362pex7mmxyphkvgznw3skkefqyqszqgpqyqszqgpqyqszqgpqyqszqgpqyqszqgpqq8ylv7&quot;</code>, in the storage keys below in place of <code>PoS</code>.</p>
<p>Note that in the query paths below (and in all storage keys in general), addresses are encoded with bech32m and prefixed with <code>#</code> character.</p>
<ul>
<li><code>#{PoS}/bond/#{validator}/#{validator}</code>: validator self-bonds, where <code>validator</code> is its bech32m encoded address</li>
<li><code>#{PoS}/bond/#{owner}/#{validator}</code>: delegation bonds, where <code>owner</code> is the delegation source and <code>validator</code> the delegation target</li>
<li><code>#{PoS}/unbond/#{validator}/#{validator}</code>: unbonded validator self-bonds, where <code>validator</code> is its bech32m encoded address</li>
<li><code>#{PoS}/unbond/#{owner}/#{validator}</code>: unbonded delegation bonds, where <code>owner</code> is the delegation source and <code>validator</code> the delegation target</li>
<li><code>#{PoS}/validator/#{validator}/voting_power</code>: <code>validator</code>'s voting power</li>
<li><code>#{PoS}/slash/#{validator}</code>: slashes applied to the <code>validator</code>, if any</li>
</ul>
<h2 id="default-validity-predicate-storage-queries"><a class="header" href="#default-validity-predicate-storage-queries">Default validity predicate storage queries</a></h2>
<p>The <a href="specs/ledger/default-validity-predicates.html">default validity predicate</a> for the implicit accounts and token accounts enforce a format for the account's storage. This storage can be queried at the following paths:</p>
<ul>
<li>public key</li>
<li>token balance</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="default-transactions"><a class="header" href="#default-transactions">Default transactions</a></h1>
<p>The Anoma client comes with a set of pre-built transactions. Note that the Anoma ledger is agnostic about the format of the transactions beyond the format described in <a href="specs/ledger/../ledger.html#transactions">ledger transaction section</a>.</p>
<p>The <a href="specs/ledger/default-validity-predicates.html">default validity predicates</a> can be used to initialize the network's genesis block. These expect the data in the storage to be encoded with <a href="specs/ledger/../encoding.html#borsh-binary-encoding">Borsh</a> and are fully compatible with the default transactions described below.</p>
<h2 id="rust-to-wasm-transactions"><a class="header" href="#rust-to-wasm-transactions">Rust-to-WASM transactions</a></h2>
<p>The following transactions are pre-built from Rust code and can be used by clients interacting with the Anoma ledger.</p>
<p>The pre-built WASM code's raw bytes should be attached to the transaction's <code>code</code> field. The transactions expect certain variables to be provided via the transaction's <code>data</code> field encoded with <a href="specs/ledger/../encoding.html#borsh-binary-encoding">Borsh</a>.</p>
<h3 id="tx_init_account"><a class="header" href="#tx_init_account">tx_init_account</a></h3>
<p>Initialize a new <a href="specs/ledger/../../explore/design/ledger/accounts.html#established-transparent-addresses">established account</a> on the chain.</p>
<p>To use this transaction, attach <a href="specs/ledger/../encoding.html#initaccount">InitAccount</a> to the <code>data</code>.</p>
<h3 id="tx_init_validator"><a class="header" href="#tx_init_validator">tx_init_validator</a></h3>
<p>Initialize a new validator account on the chain.</p>
<p>Attach <a href="specs/ledger/../encoding.html#initvalidator">InitValidator</a> to the <code>data</code>.</p>
<h3 id="tx_transfer"><a class="header" href="#tx_transfer">tx_transfer</a></h3>
<p>Transparently transfer <code>amount</code> of fungible <code>token</code> from the <code>source</code> to the <code>target</code>.</p>
<p>Attach <a href="specs/ledger/../encoding.html#transfer">Transfer</a> to the <code>data</code>.</p>
<h3 id="tx_update_vp"><a class="header" href="#tx_update_vp">tx_update_vp</a></h3>
<p>Update a validity predicate of an established account.</p>
<p>Attach <a href="specs/ledger/../encoding.html#updatevp">UpdateVp</a> to the <code>data</code>.</p>
<h3 id="tx_bond"><a class="header" href="#tx_bond">tx_bond</a></h3>
<p>Self-bond <code>amount</code> of XAN token from <code>validator</code> (without <code>source</code>) or delegate to <code>validator</code> from <code>source</code>.</p>
<p>Attach <a href="specs/ledger/../encoding.html#bond">Bond</a> to the <code>data</code>.</p>
<h3 id="tx_unbond"><a class="header" href="#tx_unbond">tx_unbond</a></h3>
<p>Unbond self-bonded <code>amount</code> of XAN token from the <code>validator</code> (without <code>source</code>) or unbond delegation from the <code>source</code> to the <code>validator</code>.</p>
<p>Attach <a href="specs/ledger/../encoding.html#bond">Bond</a> to the <code>data</code>.</p>
<h3 id="tx_withdraw"><a class="header" href="#tx_withdraw">tx_withdraw</a></h3>
<p>Withdraw unbonded self-bond from the <code>validator</code> (without <code>source</code>) or withdraw unbonded delegation from the <code>source</code> to the <code>validator</code>.</p>
<p>Attach <a href="specs/ledger/../encoding.html#withdraw">Withdraw</a> to the <code>data</code>.</p>
<h2 id="signing-transactions"><a class="header" href="#signing-transactions">Signing transactions</a></h2>
<p>To sign transactions in format that is understood and thus can be verified by the <a href="specs/ledger/default-validity-predicates.html">default validity predicates</a>, the SHA-256 hash of the <code>data</code> <a href="specs/ledger/../encoding.html#borsh-binary-encoding">encoded with Borsh</a> MUST be <a href="specs/ledger/../crypto.html#signatures">signed</a> by an implicit or established account's key. The encoded signed data together with the signature should be encoded as a <a href="specs/ledger/../encoding.html#signedtxdata"><code>SignedTxData</code></a> and also encoded with Borsh. This data should then be attached to a protobuf encoded transaction's <code>data</code> field.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="default-validity-predicates"><a class="header" href="#default-validity-predicates">Default validity predicates</a></h1>
<p>The Anoma ledger and client comes with a set of pre-built validity predicates.</p>
<h2 id="rust-to-wasm-validity-predicates"><a class="header" href="#rust-to-wasm-validity-predicates">Rust-to-WASM validity predicates</a></h2>
<p>TODO</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cryptographic-schemes"><a class="header" href="#cryptographic-schemes">Cryptographic schemes</a></h1>
<p>Anoma currently supports Ed25519 signatures with more to be added:</p>
<ul>
<li><a href="https://github.com/anoma/anoma/issues/162"><code>Secp256k1</code></a></li>
<li><a href="https://github.com/anoma/anoma/issues/646"><code>Sr25519</code></a></li>
</ul>
<p>Please note that the Anoma's crypto public API and encoding is currently undergoing some breaking changes with <a href="https://github.com/anoma/anoma/issues/225">https://github.com/anoma/anoma/issues/225</a>.</p>
<h2 id="public-keys"><a class="header" href="#public-keys">Public keys</a></h2>
<p>A public key is a <a href="specs/encoding.html#publickey">Borsh encoded <code>PublicKey</code></a>. For the Ed25519 scheme, this is 32 bytes of Ed25519 public key, prefixed with <code>32</code> in little endian encoding (<code>[32, 0, 0, 0]</code> in raw bytes or <code>20000000</code> in hex). (TODO this will change with <a href="https://github.com/anoma/anoma/issues/225">https://github.com/anoma/anoma/issues/225</a>)</p>
<h2 id="signatures"><a class="header" href="#signatures">Signatures</a></h2>
<p>A signature in Anoma is a <a href="specs/encoding.html#signature">Borsh encoded <code>Signature</code></a>. For the Ed25519 scheme, this is 64 bytes of Ed25519 signature, prefixed with <code>64</code> in little endian encoding (<code>[64, 0, 0, 0]</code> in raw bytes or <code>40000000</code> in hex). (TODO this will change with <a href="https://github.com/anoma/anoma/issues/225">https://github.com/anoma/anoma/issues/225</a>)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="encoding"><a class="header" href="#encoding">Encoding</a></h1>
<h2 id="the-ledger-3"><a class="header" href="#the-ledger-3">The ledger</a></h2>
<p>Most of the data in Anoma are encoded with <a href="specs/encoding.html#borsh-binary-encoding">Borsh</a>, except for the outer layer of <a href="specs/encoding.html#transactions">transactions</a> that are being passed via Tendermint and therefore are required to be encoded with protobuf.</p>
<h3 id="borsh-binary-encoding"><a class="header" href="#borsh-binary-encoding">Borsh binary encoding</a></h3>
<p>The encoding schemas below are described in terms of <a href="https://github.com/nearprotocol/borsh#specification">Borsh specification</a>, following the general principles (<a href="https://github.com/near/borsh/blob/master/README.md#specification">verbatim from Borsh</a>):</p>
<ul>
<li>integers are little endian;</li>
<li>sizes of dynamic containers are written before values as <code>u32</code>;</li>
<li>all unordered containers (hashmap/hashset) are ordered in lexicographic order by key (in tie breaker case on value);</li>
<li>structs are serialized in the order of fields in the struct;</li>
<li>enums are serialized with using <code>u8</code> for the enum ordinal and then storing data inside the enum value (if present).</li>
</ul>
<p>Note that &quot;nil&quot; corresponds to unit (<code>()</code>) which is encoded as empty bytes (nothing is being written).</p>
<!--- The file included below is generated by the `encoding_spec` crate. To re-generate, run `cargo run --bin anoma_encoding_spec`. -->
<!--- THIS PAGE IS GENERATED FROM CODE: encoding_spec/src/main.rs. Do not edit manually! -->
<h4 id="address"><a class="header" href="#address">Address</a></h4>
<p>Enum (<a href="https://dev.anoma.net/master/rustdoc/anoma/types/address/enum.Address.html">rust-doc</a>)</p>
<table><thead><tr><th>Prefix byte</th><th>Name</th><th>Type</th></tr></thead><tbody>
<tr><td>0</td><td>Established</td><td><a href="specs/encoding.html#addressestablished">AddressEstablished</a></td></tr>
<tr><td>1</td><td>Implicit</td><td><a href="specs/encoding.html#addressimplicit">AddressImplicit</a></td></tr>
<tr><td>2</td><td>Internal</td><td><a href="specs/encoding.html#addressinternal">AddressInternal</a></td></tr>
</tbody></table>
<h4 id="amount"><a class="header" href="#amount">Amount</a></h4>
<p>Struct with named fields (<a href="https://dev.anoma.net/master/rustdoc/anoma/types/token/struct.Amount.html">rust-doc</a>)</p>
<table><thead><tr><th>Position</th><th>Name</th><th>Type</th></tr></thead><tbody>
<tr><td>0</td><td>micro</td><td>u64 (native type)</td></tr>
</tbody></table>
<h4 id="epoch-1"><a class="header" href="#epoch-1">Epoch</a></h4>
<p>Struct with unnamed fields (<a href="https://dev.anoma.net/master/rustdoc/anoma/types/storage/struct.Epoch.html">rust-doc</a>)</p>
<table><thead><tr><th>Position</th><th>Type</th></tr></thead><tbody>
<tr><td>0</td><td>u64 (native type)</td></tr>
</tbody></table>
<h4 id="parameters-1"><a class="header" href="#parameters-1">Parameters</a></h4>
<p>Struct with named fields (<a href="file:///Users/tz/dev/anoma/target/doc/anoma/ledger/parameters/struct.Parameters.html">rust-doc</a>)</p>
<table><thead><tr><th>Position</th><th>Name</th><th>Type</th></tr></thead><tbody>
<tr><td>0</td><td>epoch_duration</td><td><a href="specs/encoding.html#epochduration">EpochDuration</a></td></tr>
<tr><td>1</td><td>max_expected_time_per_block</td><td><a href="specs/encoding.html#durationsecs">DurationSecs</a></td></tr>
<tr><td>2</td><td>vp_whitelist</td><td><a href="specs/encoding.html#vecstring">Vec&lt;string&gt;</a></td></tr>
<tr><td>3</td><td>tx_whitelist</td><td><a href="specs/encoding.html#vecstring">Vec&lt;string&gt;</a></td></tr>
</tbody></table>
<h4 id="ed25519publickey"><a class="header" href="#ed25519publickey">ed25519::PublicKey</a></h4>
<p>Fixed-size array with 32 elements of u8 (native type) (<a href="https://dev.anoma.net/master/rustdoc/anoma/types/key/ed25519/struct.PublicKey.html">rust-doc</a>)</p>
<h4 id="ed25519signature"><a class="header" href="#ed25519signature">ed25519::Signature</a></h4>
<p>Fixed-size array with 64 elements of u8 (native type) (<a href="https://dev.anoma.net/master/rustdoc/anoma/types/key/ed25519/struct.Signature.html">rust-doc</a>)</p>
<h4 id="signedtxdata"><a class="header" href="#signedtxdata">SignedTxData</a></h4>
<p>Struct with named fields (<a href="https://dev.anoma.net/master/rustdoc/anoma/types/key/ed25519/struct.SignedTxData.html">rust-doc</a>)</p>
<table><thead><tr><th>Position</th><th>Name</th><th>Type</th></tr></thead><tbody>
<tr><td>0</td><td>data</td><td><a href="specs/encoding.html#optionvecu8">Option&lt;Vec&lt;u8&gt;&gt;</a></td></tr>
<tr><td>1</td><td>sig</td><td><a href="specs/encoding.html#signature">Signature</a></td></tr>
</tbody></table>
<h4 id="initaccount"><a class="header" href="#initaccount">InitAccount</a></h4>
<p>Struct with named fields (<a href="https://dev.anoma.net/master/rustdoc/anoma/types/transaction/struct.InitAccount.html">rust-doc</a>)</p>
<table><thead><tr><th>Position</th><th>Name</th><th>Type</th></tr></thead><tbody>
<tr><td>0</td><td>public_key</td><td><a href="specs/encoding.html#publickey">PublicKey</a></td></tr>
<tr><td>1</td><td>vp_code</td><td><a href="specs/encoding.html#vecu8">Vec&lt;u8&gt;</a></td></tr>
</tbody></table>
<h4 id="initvalidator"><a class="header" href="#initvalidator">InitValidator</a></h4>
<p>Struct with named fields (<a href="https://dev.anoma.net/master/rustdoc/anoma/types/transaction/struct.InitValidator.html">rust-doc</a>)</p>
<table><thead><tr><th>Position</th><th>Name</th><th>Type</th></tr></thead><tbody>
<tr><td>0</td><td>account_key</td><td><a href="specs/encoding.html#publickey">PublicKey</a></td></tr>
<tr><td>1</td><td>consensus_key</td><td><a href="specs/encoding.html#publickey">PublicKey</a></td></tr>
<tr><td>2</td><td>rewards_account_key</td><td><a href="specs/encoding.html#publickey">PublicKey</a></td></tr>
<tr><td>3</td><td>protocol_key</td><td><a href="specs/encoding.html#publickey">PublicKey</a></td></tr>
<tr><td>4</td><td>dkg_key</td><td><a href="specs/encoding.html#dkgpublickey">DkgPublicKey</a></td></tr>
<tr><td>5</td><td>validator_vp_code</td><td><a href="specs/encoding.html#vecu8">Vec&lt;u8&gt;</a></td></tr>
<tr><td>6</td><td>rewards_vp_code</td><td><a href="specs/encoding.html#vecu8">Vec&lt;u8&gt;</a></td></tr>
</tbody></table>
<h4 id="transfer"><a class="header" href="#transfer">Transfer</a></h4>
<p>Struct with named fields (<a href="https://dev.anoma.net/master/rustdoc/anoma/types/token/struct.Transfer.html">rust-doc</a>)</p>
<table><thead><tr><th>Position</th><th>Name</th><th>Type</th></tr></thead><tbody>
<tr><td>0</td><td>source</td><td><a href="specs/encoding.html#address">Address</a></td></tr>
<tr><td>1</td><td>target</td><td><a href="specs/encoding.html#address">Address</a></td></tr>
<tr><td>2</td><td>token</td><td><a href="specs/encoding.html#address">Address</a></td></tr>
<tr><td>3</td><td>amount</td><td><a href="specs/encoding.html#amount">Amount</a></td></tr>
</tbody></table>
<h4 id="updatevp"><a class="header" href="#updatevp">UpdateVp</a></h4>
<p>Struct with named fields (<a href="https://dev.anoma.net/master/rustdoc/anoma/types/transaction/struct.UpdateVp.html">rust-doc</a>)</p>
<table><thead><tr><th>Position</th><th>Name</th><th>Type</th></tr></thead><tbody>
<tr><td>0</td><td>addr</td><td><a href="specs/encoding.html#address">Address</a></td></tr>
<tr><td>1</td><td>vp_code</td><td><a href="specs/encoding.html#vecu8">Vec&lt;u8&gt;</a></td></tr>
</tbody></table>
<h4 id="bond"><a class="header" href="#bond">Bond</a></h4>
<p>Struct with named fields (<a href="https://dev.anoma.net/master/rustdoc/anoma/types/transaction/pos/struct.Bond.html">rust-doc</a>)</p>
<table><thead><tr><th>Position</th><th>Name</th><th>Type</th></tr></thead><tbody>
<tr><td>0</td><td>validator</td><td><a href="specs/encoding.html#address">Address</a></td></tr>
<tr><td>1</td><td>amount</td><td><a href="specs/encoding.html#amount">Amount</a></td></tr>
<tr><td>2</td><td>source</td><td><a href="specs/encoding.html#optionaddress">Option&lt;Address&gt;</a></td></tr>
</tbody></table>
<h4 id="withdraw"><a class="header" href="#withdraw">Withdraw</a></h4>
<p>Struct with named fields (<a href="https://dev.anoma.net/master/rustdoc/anoma/types/transaction/pos/struct.Withdraw.html">rust-doc</a>)</p>
<table><thead><tr><th>Position</th><th>Name</th><th>Type</th></tr></thead><tbody>
<tr><td>0</td><td>validator</td><td><a href="specs/encoding.html#address">Address</a></td></tr>
<tr><td>1</td><td>source</td><td><a href="specs/encoding.html#optionaddress">Option&lt;Address&gt;</a></td></tr>
</tbody></table>
<h4 id="wrappertx"><a class="header" href="#wrappertx">WrapperTx</a></h4>
<p>Struct with named fields (<a href="https://dev.anoma.net/master/rustdoc/anoma/types/transaction/wrapper/wrapper_tx/struct.WrapperTx.html">rust-doc</a>)</p>
<table><thead><tr><th>Position</th><th>Name</th><th>Type</th></tr></thead><tbody>
<tr><td>0</td><td>fee</td><td><a href="specs/encoding.html#fee">Fee</a></td></tr>
<tr><td>1</td><td>pk</td><td><a href="specs/encoding.html#publickey">PublicKey</a></td></tr>
<tr><td>2</td><td>epoch</td><td><a href="specs/encoding.html#epoch">Epoch</a></td></tr>
<tr><td>3</td><td>gas_limit</td><td><a href="specs/encoding.html#gaslimit">GasLimit</a></td></tr>
<tr><td>4</td><td>inner_tx</td><td><a href="specs/encoding.html#encryptedtx">EncryptedTx</a></td></tr>
<tr><td>5</td><td>tx_hash</td><td><a href="specs/encoding.html#hash">Hash</a></td></tr>
</tbody></table>
<h4 id="txtype"><a class="header" href="#txtype">TxType</a></h4>
<p>Enum (<a href="https://dev.anoma.net/master/rustdoc/anoma/types/transaction/tx_types/enum.TxType.html">rust-doc</a>)</p>
<table><thead><tr><th>Prefix byte</th><th>Name</th><th>Type</th></tr></thead><tbody>
<tr><td>0</td><td>Raw</td><td><a href="specs/encoding.html#txtyperaw">TxTypeRaw</a></td></tr>
<tr><td>1</td><td>Wrapper</td><td><a href="specs/encoding.html#txtypewrapper">TxTypeWrapper</a></td></tr>
<tr><td>2</td><td>Decrypted</td><td><a href="specs/encoding.html#txtypedecrypted">TxTypeDecrypted</a></td></tr>
<tr><td>3</td><td>Protocol</td><td><a href="specs/encoding.html#txtypeprotocol">TxTypeProtocol</a></td></tr>
</tbody></table>
<h4 id="prefixvalue"><a class="header" href="#prefixvalue">PrefixValue</a></h4>
<p>Struct with named fields (<a href="https://dev.anoma.net/master/rustdoc/anoma/types/transaction/prefix_values/enum.TxType.html">rust-doc</a>)</p>
<table><thead><tr><th>Position</th><th>Name</th><th>Type</th></tr></thead><tbody>
<tr><td>0</td><td>key</td><td><a href="specs/encoding.html#key">Key</a></td></tr>
<tr><td>1</td><td>value</td><td><a href="specs/encoding.html#vecu8">Vec&lt;u8&gt;</a></td></tr>
</tbody></table>
<h4 id="addressestablished"><a class="header" href="#addressestablished">AddressEstablished</a></h4>
<p>Struct with unnamed fields</p>
<table><thead><tr><th>Position</th><th>Type</th></tr></thead><tbody>
<tr><td>0</td><td><a href="specs/encoding.html#establishedaddress">EstablishedAddress</a></td></tr>
</tbody></table>
<h4 id="addressimplicit"><a class="header" href="#addressimplicit">AddressImplicit</a></h4>
<p>Struct with unnamed fields</p>
<table><thead><tr><th>Position</th><th>Type</th></tr></thead><tbody>
<tr><td>0</td><td><a href="specs/encoding.html#implicitaddress">ImplicitAddress</a></td></tr>
</tbody></table>
<h4 id="addressinternal"><a class="header" href="#addressinternal">AddressInternal</a></h4>
<p>Struct with unnamed fields</p>
<table><thead><tr><th>Position</th><th>Type</th></tr></thead><tbody>
<tr><td>0</td><td><a href="specs/encoding.html#internaladdress">InternalAddress</a></td></tr>
</tbody></table>
<h4 id="arrayu8-32"><a class="header" href="#arrayu8-32">Array&lt;u8, 32&gt;</a></h4>
<p>Fixed-size array with 32 elements of u8 (native type)</p>
<h4 id="datetimeutc"><a class="header" href="#datetimeutc">DateTimeUtc</a></h4>
<p>Struct with unnamed fields</p>
<table><thead><tr><th>Position</th><th>Type</th></tr></thead><tbody>
<tr><td>0</td><td>string (native type)</td></tr>
</tbody></table>
<h4 id="dbkeyseg"><a class="header" href="#dbkeyseg">DbKeySeg</a></h4>
<p>Enum</p>
<table><thead><tr><th>Prefix byte</th><th>Name</th><th>Type</th></tr></thead><tbody>
<tr><td>0</td><td>AddressSeg</td><td><a href="specs/encoding.html#dbkeysegaddressseg">DbKeySegAddressSeg</a></td></tr>
<tr><td>1</td><td>StringSeg</td><td><a href="specs/encoding.html#dbkeysegstringseg">DbKeySegStringSeg</a></td></tr>
</tbody></table>
<h4 id="dbkeysegaddressseg"><a class="header" href="#dbkeysegaddressseg">DbKeySegAddressSeg</a></h4>
<p>Struct with unnamed fields</p>
<table><thead><tr><th>Position</th><th>Type</th></tr></thead><tbody>
<tr><td>0</td><td><a href="specs/encoding.html#address">Address</a></td></tr>
</tbody></table>
<h4 id="dbkeysegstringseg"><a class="header" href="#dbkeysegstringseg">DbKeySegStringSeg</a></h4>
<p>Struct with unnamed fields</p>
<table><thead><tr><th>Position</th><th>Type</th></tr></thead><tbody>
<tr><td>0</td><td>string (native type)</td></tr>
</tbody></table>
<h4 id="decryptedtx"><a class="header" href="#decryptedtx">DecryptedTx</a></h4>
<p>Enum</p>
<table><thead><tr><th>Prefix byte</th><th>Name</th><th>Type</th></tr></thead><tbody>
<tr><td>0</td><td>Decrypted</td><td><a href="specs/encoding.html#decryptedtxdecrypted">DecryptedTxDecrypted</a></td></tr>
<tr><td>1</td><td>Undecryptable</td><td><a href="specs/encoding.html#decryptedtxundecryptable">DecryptedTxUndecryptable</a></td></tr>
</tbody></table>
<h4 id="decryptedtxdecrypted"><a class="header" href="#decryptedtxdecrypted">DecryptedTxDecrypted</a></h4>
<p>Struct with unnamed fields</p>
<table><thead><tr><th>Position</th><th>Type</th></tr></thead><tbody>
<tr><td>0</td><td><a href="specs/encoding.html#tx">Tx</a></td></tr>
</tbody></table>
<h4 id="decryptedtxundecryptable"><a class="header" href="#decryptedtxundecryptable">DecryptedTxUndecryptable</a></h4>
<p>Struct with unnamed fields</p>
<table><thead><tr><th>Position</th><th>Type</th></tr></thead><tbody>
<tr><td>0</td><td><a href="specs/encoding.html#wrappertx">WrapperTx</a></td></tr>
</tbody></table>
<h4 id="dkgmessage"><a class="header" href="#dkgmessage">DkgMessage</a></h4>
<p>Dynamic-size array of u8 (native type)</p>
<h4 id="dkgpublickey"><a class="header" href="#dkgpublickey">DkgPublicKey</a></h4>
<p>Dynamic-size array of u8 (native type)</p>
<h4 id="durationsecs"><a class="header" href="#durationsecs">DurationSecs</a></h4>
<p>Struct with unnamed fields</p>
<table><thead><tr><th>Position</th><th>Type</th></tr></thead><tbody>
<tr><td>0</td><td>u64 (native type)</td></tr>
</tbody></table>
<h4 id="encryptedtx"><a class="header" href="#encryptedtx">EncryptedTx</a></h4>
<p>Tuple of (<a href="specs/encoding.html#vecu8">Vec&lt;u8&gt;</a>, <a href="specs/encoding.html#vecu8">Vec&lt;u8&gt;</a>, <a href="specs/encoding.html#vecu8">Vec&lt;u8&gt;</a>)</p>
<h4 id="epochduration"><a class="header" href="#epochduration">EpochDuration</a></h4>
<p>Struct with named fields</p>
<table><thead><tr><th>Position</th><th>Name</th><th>Type</th></tr></thead><tbody>
<tr><td>0</td><td>min_num_of_blocks</td><td>u64 (native type)</td></tr>
<tr><td>1</td><td>min_duration</td><td><a href="specs/encoding.html#durationsecs">DurationSecs</a></td></tr>
</tbody></table>
<h4 id="establishedaddress"><a class="header" href="#establishedaddress">EstablishedAddress</a></h4>
<p>Struct with named fields</p>
<table><thead><tr><th>Position</th><th>Name</th><th>Type</th></tr></thead><tbody>
<tr><td>0</td><td>hash</td><td>string (native type)</td></tr>
</tbody></table>
<h4 id="fee"><a class="header" href="#fee">Fee</a></h4>
<p>Struct with named fields</p>
<table><thead><tr><th>Position</th><th>Name</th><th>Type</th></tr></thead><tbody>
<tr><td>0</td><td>amount</td><td><a href="specs/encoding.html#amount">Amount</a></td></tr>
<tr><td>1</td><td>token</td><td><a href="specs/encoding.html#address">Address</a></td></tr>
</tbody></table>
<h4 id="gaslimit"><a class="header" href="#gaslimit">GasLimit</a></h4>
<p>Struct with named fields</p>
<table><thead><tr><th>Position</th><th>Name</th><th>Type</th></tr></thead><tbody>
<tr><td>0</td><td>multiplier</td><td>u64 (native type)</td></tr>
</tbody></table>
<h4 id="hash"><a class="header" href="#hash">Hash</a></h4>
<p>Struct with unnamed fields</p>
<table><thead><tr><th>Position</th><th>Type</th></tr></thead><tbody>
<tr><td>0</td><td><a href="specs/encoding.html#arrayu8-32">Array&lt;u8, 32&gt;</a></td></tr>
</tbody></table>
<h4 id="implicitaddress"><a class="header" href="#implicitaddress">ImplicitAddress</a></h4>
<p>Struct with unnamed fields</p>
<table><thead><tr><th>Position</th><th>Type</th></tr></thead><tbody>
<tr><td>0</td><td><a href="specs/encoding.html#publickeyhash">PublicKeyHash</a></td></tr>
</tbody></table>
<h4 id="internaladdress"><a class="header" href="#internaladdress">InternalAddress</a></h4>
<p>Enum</p>
<table><thead><tr><th>Prefix byte</th><th>Name</th><th>Type</th></tr></thead><tbody>
<tr><td>0</td><td>PoS</td><td><a href="specs/encoding.html#internaladdresspos">InternalAddressPoS</a></td></tr>
<tr><td>1</td><td>PosSlashPool</td><td><a href="specs/encoding.html#internaladdressposslashpool">InternalAddressPosSlashPool</a></td></tr>
<tr><td>2</td><td>Ibc</td><td><a href="specs/encoding.html#internaladdressibc">InternalAddressIbc</a></td></tr>
<tr><td>3</td><td>Parameters</td><td><a href="specs/encoding.html#internaladdressparameters">InternalAddressParameters</a></td></tr>
<tr><td>4</td><td>IbcEscrow</td><td><a href="specs/encoding.html#internaladdressibcescrow">InternalAddressIbcEscrow</a></td></tr>
<tr><td>5</td><td>IbcBurn</td><td><a href="specs/encoding.html#internaladdressibcburn">InternalAddressIbcBurn</a></td></tr>
<tr><td>6</td><td>IbcMint</td><td><a href="specs/encoding.html#internaladdressibcmint">InternalAddressIbcMint</a></td></tr>
<tr><td>7</td><td>Governance</td><td><a href="specs/encoding.html#internaladdressgovernance">InternalAddressGovernance</a></td></tr>
</tbody></table>
<h4 id="internaladdressgovernance"><a class="header" href="#internaladdressgovernance">InternalAddressGovernance</a></h4>
<p>Empty struct (unit)</p>
<h4 id="internaladdressibc"><a class="header" href="#internaladdressibc">InternalAddressIbc</a></h4>
<p>Empty struct (unit)</p>
<h4 id="internaladdressibcburn"><a class="header" href="#internaladdressibcburn">InternalAddressIbcBurn</a></h4>
<p>Empty struct (unit)</p>
<h4 id="internaladdressibcescrow"><a class="header" href="#internaladdressibcescrow">InternalAddressIbcEscrow</a></h4>
<p>Struct with unnamed fields</p>
<table><thead><tr><th>Position</th><th>Type</th></tr></thead><tbody>
<tr><td>0</td><td>string (native type)</td></tr>
</tbody></table>
<h4 id="internaladdressibcmint"><a class="header" href="#internaladdressibcmint">InternalAddressIbcMint</a></h4>
<p>Empty struct (unit)</p>
<h4 id="internaladdressparameters"><a class="header" href="#internaladdressparameters">InternalAddressParameters</a></h4>
<p>Empty struct (unit)</p>
<h4 id="internaladdresspos"><a class="header" href="#internaladdresspos">InternalAddressPoS</a></h4>
<p>Empty struct (unit)</p>
<h4 id="internaladdressposslashpool"><a class="header" href="#internaladdressposslashpool">InternalAddressPosSlashPool</a></h4>
<p>Empty struct (unit)</p>
<h4 id="key"><a class="header" href="#key">Key</a></h4>
<p>Struct with named fields</p>
<table><thead><tr><th>Position</th><th>Name</th><th>Type</th></tr></thead><tbody>
<tr><td>0</td><td>segments</td><td><a href="specs/encoding.html#vecdbkeyseg">Vec&lt;DbKeySeg&gt;</a></td></tr>
</tbody></table>
<h4 id="optionaddress"><a class="header" href="#optionaddress">Option&lt;Address&gt;</a></h4>
<p>Enum</p>
<table><thead><tr><th>Prefix byte</th><th>Name</th><th>Type</th></tr></thead><tbody>
<tr><td>0</td><td>None</td><td>nil (native type)</td></tr>
<tr><td>1</td><td>Some</td><td><a href="specs/encoding.html#address">Address</a></td></tr>
</tbody></table>
<h4 id="optionvecu8"><a class="header" href="#optionvecu8">Option&lt;Vec&lt;u8&gt;&gt;</a></h4>
<p>Enum</p>
<table><thead><tr><th>Prefix byte</th><th>Name</th><th>Type</th></tr></thead><tbody>
<tr><td>0</td><td>None</td><td>nil (native type)</td></tr>
<tr><td>1</td><td>Some</td><td><a href="specs/encoding.html#vecu8">Vec&lt;u8&gt;</a></td></tr>
</tbody></table>
<h4 id="protocoltx"><a class="header" href="#protocoltx">ProtocolTx</a></h4>
<p>Struct with named fields</p>
<table><thead><tr><th>Position</th><th>Name</th><th>Type</th></tr></thead><tbody>
<tr><td>0</td><td>pk</td><td><a href="specs/encoding.html#publickey">PublicKey</a></td></tr>
<tr><td>1</td><td>tx</td><td><a href="specs/encoding.html#protocoltxtype">ProtocolTxType</a></td></tr>
</tbody></table>
<h4 id="protocoltxtype"><a class="header" href="#protocoltxtype">ProtocolTxType</a></h4>
<p>Enum</p>
<table><thead><tr><th>Prefix byte</th><th>Name</th><th>Type</th></tr></thead><tbody>
<tr><td>0</td><td>DKG</td><td><a href="specs/encoding.html#protocoltxtypedkg">ProtocolTxTypeDKG</a></td></tr>
<tr><td>1</td><td>NewDkgKeypair</td><td><a href="specs/encoding.html#protocoltxtypenewdkgkeypair">ProtocolTxTypeNewDkgKeypair</a></td></tr>
<tr><td>2</td><td>EthereumStateUpdate</td><td><a href="specs/encoding.html#protocoltxtypeethereumstateupdate">ProtocolTxTypeEthereumStateUpdate</a></td></tr>
</tbody></table>
<h4 id="protocoltxtypedkg"><a class="header" href="#protocoltxtypedkg">ProtocolTxTypeDKG</a></h4>
<p>Struct with unnamed fields</p>
<table><thead><tr><th>Position</th><th>Type</th></tr></thead><tbody>
<tr><td>0</td><td><a href="specs/encoding.html#dkgmessage">DkgMessage</a></td></tr>
</tbody></table>
<h4 id="protocoltxtypeethereumstateupdate"><a class="header" href="#protocoltxtypeethereumstateupdate">ProtocolTxTypeEthereumStateUpdate</a></h4>
<p>Struct with unnamed fields</p>
<table><thead><tr><th>Position</th><th>Type</th></tr></thead><tbody>
<tr><td>0</td><td><a href="specs/encoding.html#tx">Tx</a></td></tr>
</tbody></table>
<h4 id="protocoltxtypenewdkgkeypair"><a class="header" href="#protocoltxtypenewdkgkeypair">ProtocolTxTypeNewDkgKeypair</a></h4>
<p>Struct with unnamed fields</p>
<table><thead><tr><th>Position</th><th>Type</th></tr></thead><tbody>
<tr><td>0</td><td><a href="specs/encoding.html#tx">Tx</a></td></tr>
</tbody></table>
<h4 id="publickey"><a class="header" href="#publickey">PublicKey</a></h4>
<p>Enum</p>
<table><thead><tr><th>Prefix byte</th><th>Name</th><th>Type</th></tr></thead><tbody>
<tr><td>0</td><td>Ed25519</td><td><a href="specs/encoding.html#publickeyed25519">PublicKeyEd25519</a></td></tr>
</tbody></table>
<h4 id="publickeyed25519"><a class="header" href="#publickeyed25519">PublicKeyEd25519</a></h4>
<p>Struct with unnamed fields</p>
<table><thead><tr><th>Position</th><th>Type</th></tr></thead><tbody>
<tr><td>0</td><td><a href="specs/encoding.html#ed25519::publickey">ed25519::PublicKey</a></td></tr>
</tbody></table>
<h4 id="publickeyhash"><a class="header" href="#publickeyhash">PublicKeyHash</a></h4>
<p>Struct with unnamed fields</p>
<table><thead><tr><th>Position</th><th>Type</th></tr></thead><tbody>
<tr><td>0</td><td>string (native type)</td></tr>
</tbody></table>
<h4 id="signature"><a class="header" href="#signature">Signature</a></h4>
<p>Enum</p>
<table><thead><tr><th>Prefix byte</th><th>Name</th><th>Type</th></tr></thead><tbody>
<tr><td>0</td><td>Ed25519</td><td><a href="specs/encoding.html#signatureed25519">SignatureEd25519</a></td></tr>
</tbody></table>
<h4 id="signatureed25519"><a class="header" href="#signatureed25519">SignatureEd25519</a></h4>
<p>Struct with unnamed fields</p>
<table><thead><tr><th>Position</th><th>Type</th></tr></thead><tbody>
<tr><td>0</td><td><a href="specs/encoding.html#ed25519::signature">ed25519::Signature</a></td></tr>
</tbody></table>
<h4 id="tx"><a class="header" href="#tx">Tx</a></h4>
<p>Struct with named fields</p>
<table><thead><tr><th>Position</th><th>Name</th><th>Type</th></tr></thead><tbody>
<tr><td>0</td><td>code</td><td><a href="specs/encoding.html#vecu8">Vec&lt;u8&gt;</a></td></tr>
<tr><td>1</td><td>data</td><td><a href="specs/encoding.html#optionvecu8">Option&lt;Vec&lt;u8&gt;&gt;</a></td></tr>
<tr><td>2</td><td>timestamp</td><td><a href="specs/encoding.html#datetimeutc">DateTimeUtc</a></td></tr>
</tbody></table>
<h4 id="txtypedecrypted"><a class="header" href="#txtypedecrypted">TxTypeDecrypted</a></h4>
<p>Struct with unnamed fields</p>
<table><thead><tr><th>Position</th><th>Type</th></tr></thead><tbody>
<tr><td>0</td><td><a href="specs/encoding.html#decryptedtx">DecryptedTx</a></td></tr>
</tbody></table>
<h4 id="txtypeprotocol"><a class="header" href="#txtypeprotocol">TxTypeProtocol</a></h4>
<p>Struct with unnamed fields</p>
<table><thead><tr><th>Position</th><th>Type</th></tr></thead><tbody>
<tr><td>0</td><td><a href="specs/encoding.html#protocoltx">ProtocolTx</a></td></tr>
</tbody></table>
<h4 id="txtyperaw"><a class="header" href="#txtyperaw">TxTypeRaw</a></h4>
<p>Struct with unnamed fields</p>
<table><thead><tr><th>Position</th><th>Type</th></tr></thead><tbody>
<tr><td>0</td><td><a href="specs/encoding.html#tx">Tx</a></td></tr>
</tbody></table>
<h4 id="txtypewrapper"><a class="header" href="#txtypewrapper">TxTypeWrapper</a></h4>
<p>Struct with unnamed fields</p>
<table><thead><tr><th>Position</th><th>Type</th></tr></thead><tbody>
<tr><td>0</td><td><a href="specs/encoding.html#wrappertx">WrapperTx</a></td></tr>
</tbody></table>
<h4 id="vecdbkeyseg"><a class="header" href="#vecdbkeyseg">Vec&lt;DbKeySeg&gt;</a></h4>
<p>Dynamic-size array of <a href="specs/encoding.html#dbkeyseg">DbKeySeg</a></p>
<h4 id="vecstring"><a class="header" href="#vecstring">Vec&lt;string&gt;</a></h4>
<p>Dynamic-size array of string (native type)</p>
<h4 id="vecu8"><a class="header" href="#vecu8">Vec&lt;u8&gt;</a></h4>
<p>Dynamic-size array of u8 (native type)</p>
<!--- THIS PAGE IS GENERATED FROM CODE: encoding_spec/src/main.rs. Do not edit manually! -->
<h2 id="protobuf-1"><a class="header" href="#protobuf-1">Protobuf</a></h2>
<p>The schemas below are described in terms of <a href="https://developers.google.com/protocol-buffers/docs/reference/proto3-spec">proto3 specification</a>.</p>
<p>All the data fields are REQUIRED, unless specified otherwise.</p>
<h3 id="transactions-4"><a class="header" href="#transactions-4">Transactions</a></h3>
<p>Transactions MUST be encoded in the format as defined for <a href="specs/encoding.html#proto-definitions"><code>message Tx</code></a>.</p>
<p>Note that for the <a href="specs/ledger/default-transactions.html">default transactions</a>, the <code>data</code> are <a href="specs/encoding.html#borsh-binary-encoding">encoded with Borsh</a>.</p>
<table><thead><tr><th>Name</th><th>Type</th><th>Description</th><th>Field Number</th></tr></thead><tbody>
<tr><td>code</td><td>bytes</td><td>Transaction WASM code.</td><td>1</td></tr>
<tr><td>data</td><td>optional bytes</td><td>Transaction data (OPTIONAL).</td><td>2</td></tr>
<tr><td>timestamp</td><td>google.protobuf.Timestamp</td><td>Timestamp of when the transaction was created.</td><td>3</td></tr>
</tbody></table>
<h2 id="proto-definitions"><a class="header" href="#proto-definitions">Proto definitions</a></h2>
<pre><code>syntax = &quot;proto3&quot;;

import &quot;google/protobuf/timestamp.proto&quot;;

package types;

message Tx {
  bytes code = 1;
  // TODO this optional is useless because it's default on proto3
  optional bytes data = 2;
  google.protobuf.Timestamp timestamp = 3;
}

message Intent {
  bytes data = 1;
  google.protobuf.Timestamp timestamp = 2;
}

message IntentGossipMessage{
  // TODO remove oneof because it's not used so far
  oneof msg {
    Intent intent = 1;
  }
}

message Dkg {
  string data = 1;
}

message DkgGossipMessage{
  oneof dkg_message {
    Dkg dkg = 1;
  }
}
</code></pre>
<!--- Align tables to the left -->
<style> table { margin-left:0; } </style>
<div style="break-before: page; page-break-before: always;"></div><h1 id="archive"><a class="header" href="#archive">Archive</a></h1>
<p>Deprecated pages archived for possible later re-use.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="domain-name-addresses"><a class="header" href="#domain-name-addresses">Domain name addresses</a></h1>
<p>The transparent addresses are similar to domain names and the ones used in e.g. <a href="https://eips.ethereum.org/EIPS/eip-137">ENS as specified in EIP-137</a> and <a href="https://nomicon.io/DataStructures/Account.html">account IDs in Near protocol</a>. These are the addresses of accounts associated with dynamic storage sub-spaces, where the address of the account is the prefix key segment of its sub-space.</p>
<p>A transparent address is a human-readable string very similar to a domain name, containing only alpha-numeric ASCII characters, hyphen (<code>-</code>) and full stop (<code>.</code>) as a separator between the &quot;labels&quot; of the address. The letter case is not significant and any upper case letters are converted to lower case. The last label of an address is said to be the top-level name and each predecessor segment is the sub-name of its successor.</p>
<p>The length of an address must be at least 3 characters. For compatibility with a legacy DNS TXT record, we'll use syntax as defined in <a href="https://www.ietf.org/rfc/rfc1034.txt">RFC-1034 - section 3.5 DNS preferred name syntax</a>. That is, the upper limit is 255 characters and 63 for each label in an address (which should be sufficient anyway); and the label must not begin or end with hyphen (<code>-</code>) and must not begin with a digit.</p>
<p>These addresses can be chosen by users who wish to <a href="archive/domain-name-addresses.html#initializing-a-new-account">initialize a new account</a>, following these rules:</p>
<ul>
<li>a new address must be initialized on-chain
<ul>
<li>each sub-label must be authorized by the predecessor level address (e.g. initializing address <code>free.eth</code> must be authorized by <code>eth</code>, or <code>gives.free.eth</code> by <code>free.eth</code>, etc.) </li>
<li>note that besides the address creation, each address level is considered to be a distinct address with its own dynamic storage sub-space and validity predicate.</li>
</ul>
</li>
<li>the top-level names under certain length (to be specified) cannot be initialized directly, they may be <a href="https://eips.ethereum.org/EIPS/eip-162">auctioned like in ENS registrar as described in EIP-162</a>.
<ul>
<li>some top-level names may be reserved</li>
</ul>
</li>
</ul>
<p>For convenience, the <code>anoma</code> top-level address is initially setup to allow initialization of any previously unused second-level address, e.g. <code>bob.anoma</code> (we may want to revise this before launch to e.g. auction the short ones, like with top-level names to make the process fairer).</p>
<p>Like in ENS, the addresses are stored on chain by their hash, encoded with <a href="https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki">bech32m</a> (<a href="https://github.com/zcash/zips/issues/484">not yet adopted in Zcash</a>), which is an improved version of <a href="https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki">bech32</a>. Likewise, this is for two reasons:</p>
<ul>
<li>help preserve privacy of addresses that were not revealed publicly and to prevent trivial enumeration of registered names (of course, you can still try to enumerate by hashes)</li>
<li>using fixed-length string in the ledger simplifies gas accounting</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="assets/mermaid.min.js"></script>
        <script type="text/javascript" src="assets/mermaid-init.js"></script>

        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </body>
</html>
